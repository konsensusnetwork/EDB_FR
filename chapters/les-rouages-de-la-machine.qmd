# The Inner Workings of the Machine {#ch:inner-workings}

[]{#enotezch:12 label="enotezch:12"}

[B]{.lettrine}[i]{.smallcaps}tcoin is a peculiar machine. Born out of an antagonistic stance toward authority, it possesses properties not found in common computer systems. In particular, it cannot be modified arbitrarily, which explains its original design and subsequent evolution.

On one hand, the representation of the basic units, satoshis, is not in the form of accounts where user balances are updated but through cryptocurrency coins that can be combined and split in transactions. This functioning enhances the chain's confidentiality and scalability, making it well-suited for monetary use.

On the other hand, Bitcoin incorporates an internal programming system that allows spending conditions to be embedded in the coins, sometimes referred to as autonomous contracts or *smart contracts*. Over the years, it has been improved, sometimes at the cost of increased complexity, notably with the addition of SegWit and Taproot.

In this chapter, we will examine the inner workings of this transactional machine before describing how it can be exploited and enhanced for confidentiality purposes. The next chapter will be devoted to contracts themselves.

## Transactions and Coins {#transactions-and-coins .unnumbered}

In Bitcoin, transactions play a central role. The protocol is designed to exchange value in line with its monetary function, handling transfers of ownership. The entire system is conceived to facilitate the construction, signing, and dissemination of transactions, their storage in memory in the *mempool*, and their addition to the ledger by inclusion in a block.

Each transaction consists of one or more inputs and one or more outputs. A transaction output simply comprises a destination indication and an amount in units (satoshis). An input generally refers to a previous transaction output, except in the case of the reward transaction where it represents a "coinbase" creating new units from monetary issuance and transaction fees.

A transaction's identifier (*transaction identifier* or txid) is the hash of its raw data, obtained via double SHA-256 hashing. Each transaction output is characterized by the identifier of the transaction from which it originates and by its position in that transaction, known as the index. This output point (*outpoint*) serves as a provenance indication. An example of an output point is f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16:0.

Contrary to what the description of ownership in Chapter [7](#ch:propriete) might suggest, the destination and provenance of units are not strictly addresses but locking scripts—that is, small programs that determine their spending conditions. Each output thus creates a script that locks the funds in a specific way. Most often, this script contains a public key or a public key hash, which can be interpreted as an address by the wallet.

For an input to be valid, it must contain an unlocking script whose execution, combined with that of the locking script, succeeds. Generally, this unlocking script contains a digital signature corresponding to the public key linked to the previous locking script: verifying the signature ensures that the person spending the units is the owner.

This mechanism means that the model of representing units is counterintuitive. The protocol does not perceive accounts with balances updated by transactions, as is the case in Ethereum, for example. It simply sees transaction outputs held by owners, similar to coins in the physical world.

Thus, Bitcoin implements the concept of digital coin that was discussed within the cypherpunk community in the 1990s. In the *Cyphernomicon*, for example, Tim May considered such a thing impossible due to the double-spending problem. Satoshi Nakamoto, by discovering a way to solve this problem, made the concept viable and integrated it into Bitcoin. In the white paper, he described the notion of a digital coin as follows:

"We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing the hash of the previous transaction and the next owner's public key and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership[^482]."

In Bitcoin, the existing coins are therefore the unspent transaction outputs, commonly abbreviated as UTXOs (Unspent Transaction Outputs), meaning the transaction outputs that have not been used as inputs in another transaction. The set of these coins, the *UTXO set*, constitutes the ledger of ownership. It represents the system's state, which can be retrieved from its history—the blockchain.

Each coin consists of an amount in units (satoshis) and a locking script. Thus, there can be coins of one billion satoshis (10 bitcoins) as well as coins of 546 satoshis (0.00000546 bitcoin).

The locking script of a coin most often contains a public key or a determined hash, so the coin can be viewed as being held by the corresponding address. Therefore, two coins sharing the same locking script are held by the same address. An account in Bitcoin corresponds to all the addresses controlled by a user. The balance is retrieved by scanning all the UTXOs to find the coins held by these addresses.

![Examples of coins held by the same account.](img/coins-utxos-account.png){#fig:coins-utxos}

This coin-based representation model allows us to view the transaction mechanism as a coin minting process. Each transaction involves melting together one or more bitcoin coins in inputs and minting one or more coins in outputs. This is how Bitcoin's distributed timestamp server replaces the centralized digital minting present in eCash and RPOW, for example, which allowed systematic replacement of coins.

Constructing a transaction involves gathering coins of sufficient value in inputs to melt them and mint new ones. Generally, two coins are created: the first is sent to the address provided by the recipient to make the payment (primary output), and the second is sent back to one of the sender's addresses to "give themselves change" (change output). The difference between the input amount and the output amount is accounted for in the miner's reward as transaction fees.

Let's consider some examples while ignoring these fees and assuming Alice wants to make a payment. If Alice has a coin of 12 mBTC (0.012 BTC) and wants to give 7 mBTC to Bob, she must construct and sign a transaction using this 12 mBTC coin as input, and outputs of 7 mBTC to Bob's address and 5 mBTC back to her own address. This transaction is represented in Figure [12.2](#fig:transaction-1i-2o).

![Diagram of a transaction with 1 input and 2 outputs.](img/transaction-1i-2o.png){#fig:transaction-1i-2o}

If Alice doesn't have a coin with a face value greater than 7 mBTC, she must gather coins to collect sufficient input amount, for example, a coin of 6 mBTC and one of 2 mBTC. As before, she must create a change output back to herself to give herself the change. In this case, illustrated in Figure [12.3](#fig:transaction-2i-2o), one can deduce by observing the transaction that the 7 mBTC coin is the payment result, as it would be economically irrational to merge multiple coins to send 1 mBTC.

![Diagram of a transaction with 2 inputs and 2 outputs.](img/transaction-2i-2o.png){#fig:transaction-2i-2o}

If Alice wishes to transfer all her funds to another account, she gathers all her coins (6 mBTC, 4 mBTC, 2 mBTC) to send them to a single address, as shown in Figure [12.4](#fig:transaction-3i-1o). This is called a wallet consolidation, which can be identified by an external observer due to the uniqueness of the output.

![Diagram of a transaction with 3 inputs and 1 output.](img/transaction-3i-1o.png){#fig:transaction-3i-1o}

We see that transactions are not raw transfers from one address to another but combinations and divisions of digital coins. This functioning is somewhat counterintuitive but proves useful for the system's scalability by allowing independent processing of coins, and for user confidentiality by not encouraging the consolidation of funds on a single address and facilitating the implementation of anonymization techniques like coin mixing. This model is therefore particularly suited to monetary use.

## The Virtual Machine {#the-virtual-machine .unnumbered}

The scripts within transactions make Bitcoin a system of programmable money. These scripts allow embedding various spending conditions, also called clauses, that go beyond requiring a simple signature, such as knowing a secret, waiting for a specific time period, or producing multiple signatures.

Bitcoin's implementation creates an abstract machine whose operation is replicated on all nodes of the network thanks to the consensus algorithm. It is simulated via software implementation, hence referred to as a virtual machine. More precisely, it is a state machine, whose current state is the set of existing coins—that is, the set of unspent transaction outputs (UTXOs)—and whose transitions are the transactions that destroy coins to create new ones. These transactions are assembled into blocks that are validated at regular intervals by miners. The propagation of a block across the network updates the state of the virtual machine, which is (except in the case of a fork) shared by all nodes.

Within a transaction, unlocking coins is done by executing scripts. The scripts are predicates in the mathematical sense—that is, incomplete expressions that become propositions that can be evaluated when completed by one or more elements. Thus, spending consists of combining the locking script of the previous output and the unlocking script, and executing them one after the other: the unlocking script first, followed by the locking script. Using the coin as a transaction input is approved if the execution succeeds.

The scripts are written in Bitcoin's internal programming language, designed by Satoshi Nakamoto in 2008 and unimaginatively named "Script." This programming language functions similarly to Forth, a language used in the 1970s and 1980s. It is based primarily on two data stacks, which are data structures operating on the "last in, first out" (LIFO) principle. The language essentially acts on the primary stack, making it the most important; the secondary stack allows data to be set aside during script execution.

Satoshi Nakamoto included this scripting system in Bitcoin to enable it to handle a wide variety of use cases. In June 2010, in response to Gavin Andresen, he wrote on the forum:

"The nature of Bitcoin is such that, from version 0.1 launched, its basic operation was set in stone for the rest of its existence. That's why I wanted to design Bitcoin to support all the transaction types I could think of. The problem was that each type required special support code and data fields, whether used or not, and could only cover one special case at a time. It would have been an explosion of special cases. The solution was script, which generalized the problem so that contracting parties could describe their transactions as predicates that network nodes evaluated. The nodes only need to understand the transaction to the extent of evaluating whether the sender's conditions are met[^483]."

The language consists of more than a hundred operators, also called opcodes, which act on the primary stack in one way or another. The operators are numbers encoded on 1 byte (ranging from 0 to 255) but are usually designated by a name describing their function to make reading more understandable to humans. They are written in uppercase and are often prefixed with `OP_`, though the prefix can be omitted when unambiguous. For example, the operator that verifies a signature (`0xac`) is noted `OP_CHECKSIG` or `CHECKSIG`.

Operators ranging from 1 to 75, sometimes noted as OP_PUSHBYTES_X, act by pushing data of sizes ranging from 1 to 75 bytes onto the stack. Using additional specific operators (noted OP_PUSHDATA_Y) allows for placing larger information onto the stack. Although this notation can be used, it is generally simpler to enclose an element in angle brackets to indicate that it is pushed onto the stack. For example, writing `<signature>` within a script means that the signature is pushed onto the stack.

The value returned at the end of script execution is a boolean, so the script can be valid—in which case spending the coin is approved—or invalid, in which case the transaction is rejected entirely. The script is valid if and only if the value `TRUE` ("true") is present at the top of the stack at the end of execution. It is invalid if this is not the case or if its execution halted before completion.

However, the Script language is limited. Nothing in its basic design allows for loops or access to data outside the transaction, unlike Ethereum's language, which is nearly Turing-complete. This peculiarity means it is less flexible but has the advantage of being simpler to understand and thus more secure.

A typical script example, presented by Andreas Antonopoulos[^484], involves solving a simple equation involving addition. If we consider the equation \(17 + x = 38\), the corresponding locking script is:

``` {fontsize="\\footnotesize"}
<17> ADD <38> EQUAL
```

Anyone knowing the answer can spend the coin, which is admittedly not very secure. The spend requires providing the unlocking script containing only the solution to the equation, namely 21:

``` {fontsize="\\footnotesize"}
<21>
```

The successive execution of these two scripts (see Figure [12.5](#fig:bitcoin-stack)) proceeds as follows: 1) the value 21 is placed on the stack; 2) the value 17 is placed above it; 3) the `OP_ADD` operator adds the two top values on the stack and replaces them with their sum, here 38; 4) the value 38 is placed at the top of the stack; 5) the `OP_EQUAL` operator compares the two top values on the stack and replaces them with the equality boolean, here `TRUE`. The script execution is thus successful.

![Execution of an addition script on the data stack.](img/bitcoin-stack-example.png){#fig:bitcoin-stack}

If the value had been different, say 22, the last operation would have returned the boolean `FALSE`, and the spend transaction would have been invalidated.

Many different spending conditions can be implemented with this system. Some of these conditions are simple, such as knowing a specific secret or producing a valid signature corresponding to a particular public key. Verifying knowledge of a secret (whose hash is specified in the UTXO) is done with the following scripts that push the secret onto the stack, hash it with SHA-256, and compare the result to the hash:

``` {fontsize="\\footnotesize"}
<secret> SHA256 <hash> EQUAL
```

Similarly, verifying the validity of a signature is achieved with the following scripts that push the signature, then the public key onto the stack before checking their correspondence:

``` {fontsize="\\footnotesize"}
<signature> <public key> CHECKSIG
```

Moreover, there are more advanced conditions like timelocks. These allow funds in the coin to be locked until a specific date (absolute timelock) or for a specified duration (relative timelock). The former is implemented via the `OP_CHECKLOCKTIMEVERIFY` operator, whose technical specifics are described in BIP-65. The latter is applied by the `OP_CHECKSEQUENCEVERIFY` opcode described in BIP-112.

## Classic Schemes {#classic-schemes .unnumbered}

The Script language allows for various diverse and varied functionalities. In Bitcoin's early days, the system was relatively free and allowed people to write whatever they wanted in scripts without discrimination. However, this situation was considerably risky. The main reason was that the functioning of opcodes had not yet been verified and tested, as demonstrated by the discovery in July 2010 of a vulnerability enabled by certain binary operators (CVE-2010-5137). This is why, at the end of 2010, under Gavin Andresen's initiative, it was decided to restrict the system's programmability[^485].

This restriction was applied by imposing standard script schemes, which meant that nodes configured by default would no longer relay transactions containing scripts that did not comply with this standard. Thus, this was not a restriction of the global consensus rules but of the local mempool rules that apply to transaction transmission. Standard schemes that made things simpler and safer were developed over the years. As of 2023, the standard transaction output schemes numbered eight: P2PK, P2PKH, P2MS, P2SH, NULLDATA, P2WPKH, P2WSH, and P2TR.

### P2PK: Pay to Public Key

The first scheme is Pay to Public Key (P2PK), which can be literally translated as "pay to the public key." It involves creating a coin linked to the recipient's public key, which only they can spend by signing with their private key. The locking script enabling this type of payment is:

``` {fontsize="\\footnotesize"}
<public key> CHECKSIG
```

The presence of the public key explains why "scriptPubKey" is sometimes used to refer to the locking script in general, regardless of its content.

At the time of spending, the recipient must use an unlocking script containing simply their signature:

``` {fontsize="\\footnotesize"}
<signature>
```

The presence of the signature in this script explains why "scriptSig" is sometimes used to refer to the unlocking script in general, regardless of its content. The successive execution of these two scripts allows, as we've seen, to verify that the signature provided by the user corresponds to their public key, making it valid.

The P2PK scheme was used in Bitcoin's early days for receiving payments by IP (P2IP) and for collecting mining rewards. It has now fallen into disuse in favor of a rival scheme: P2PKH.

### P2PKH: Pay to Public Key Hash

The Pay to Public Key Hash (P2PKH) scheme, literally translated as "pay to the hash of the public key," is the second type of receipt format that appeared in Bitcoin from the beginning due to Satoshi Nakamoto's design. This scheme allows for a payment not to a public key but to a hash of a public key, while ensuring that the interpreter still verifies the validity of the signature concerning the public key when spending the funds. The public key hash is considered the essential data ("payload") of the address, which in this case always begins with a 1, such as 1FjBKPQ7MTiPSDkJ2ZwPgAXUKQ8yoGbVJX. The locking script here is:

``` {fontsize="\\footnotesize"}
DUP HASH160 <public key hash> EQUALVERIFY CHECKSIG
```

And the unlocking script is:

``` {fontsize="\\footnotesize"}
<signature> <public key>
```

The execution of the two scripts allows: 1) verifying that hashing the public key with the HASH-160 function equals the hash specified in the script; 2) verifying that the signature corresponds to the public key.

The advantage of this scheme is that it allows for shorter addresses (the information to encode is only 20 bytes instead of 33 or 65 bytes for a public key), which is why Satoshi Nakamoto implemented it. Additionally, by not revealing the public key until the time of spending, this scheme increases security against the very hypothetical threat of quantum computers.

### P2MS: Pay to MultiSig

The Pay to MultiSig (P2MS) scheme, meaning "pay to multisignature," is a multiparty signature scheme requiring the signatures of M people among N predetermined participants ("M-of-N"). It was standardized in a form limited to 3 participants in March 2012 with the release of version 0.6.0 of the software. The locking script is as follows:

``` {fontsize="\\footnotesize"}
M <public key 1> ... <public key N> N CHECKMULTISIG
```

The corresponding unlocking script is:

``` {fontsize="\\footnotesize"}
<dummy (0)> <signature 1> ... <signature M>
```

The presence of the dummy (usually 0) is due to a defect in Satoshi's implementation of the execution of the `OP_CHECKMULTISIG` operator, which requires one extra element. Developers did not deem it appropriate to fix this defect, as the correction would have been a hard fork.

This scheme, particularly demanding in terms of setup, motivated the creation of the P2SH scheme.

### P2SH: Pay to Script Hash

The Pay to Script Hash (P2SH) scheme, which can be literally translated as "pay to the script hash," extends the idea behind P2PKH, with the only difference being that the hashed data is not a public key but the script itself! The script in question is then called the redeem script to differentiate it from the unlocking script. Its hash is the essential data of the address, which always begins with a 3, like 3K8Ps6Ayw5ZaKDaLZjfGo3mTgDsc1VXZ8d.

This scheme allows the user to include any script without discrimination on its format, provided it respects certain limits. It also enables receiving funds from almost all existing wallets, with the burden of constructing and unlocking the script falling solely on the recipient and not shared with the sender, as in the case of using raw scripts.

The locking script for the P2SH scheme is:

``` {fontsize="\\footnotesize"}
HASH160 <redeem script hash> EQUAL
```

And the unlocking script is a script of the form:

``` {fontsize="\\footnotesize"}
[unlocking elements] <redeem script>
```

The execution of P2SH is more complex than previous schemes, which can be explained by the context in which it was developed. The idea of implementing a script scheme that uses a script hash like the public key hash in P2PKH emerged in 2011 through several proposals. It became more concrete with Nicolas van Saberhagen's proposal of the `OP_EVAL` operator on October 2—a code operation that allowed recursive execution of a script within another script[^486]. Gavin Andresen explained how to make it a soft fork by replacing the no-effect instruction `OP_NOP1`[^487].

The `OP_EVAL` operator was intended to form a new standard scheme. The locking script would have been:

``` {fontsize="\\footnotesize"}
DUP HASH160 <redeem script hash> EQUALVERIFY EVAL
```

while the unlocking script would have been the same as for P2SH. The successive execution of these two scripts would have allowed, first, verifying the hash of the redeem script matches the specified hash; then, in a second step, executing the redeem script and combining it with the unlocking elements. However, this solution was not accepted, being judged too dangerous because of its recursion power. An alternative model, more restrictive, was preferred: P2SH.

The execution of P2SH works exactly like the scheme related to `OP_EVAL`, except that part of the script is not explicitly indicated. On one hand, verifying the correspondence between the specified hash and the redeem script is done by the locking script. On the other hand, the evaluation of the redeem script is performed implicitly thanks to an exception added to the source code, causing network nodes recognizing the scheme to interpret it differently. In Bitcoin Core, this condition can be observed within the VerifyScript function of the interpreter.

The proposal was codified in BIP-16. While this solution is practical, it creates complexity and is not very elegant. As Gavin Andresen said in the introductory explanation of this BIP:

"Recognizing a 'special' form of scriptPubKey and performing additional validation when it is detected is ugly. However, the general consensus is that the alternatives are either even uglier, more complex to implement, and/or dangerously extend the language's expressive power[^488]."

The P2SH scheme was eventually activated on April 1, 2012, as a soft fork, despite notable opposition from Luke-Jr, who proposed an alternative operator, `OP_CHECKHASHVERIFY`, described in BIP-17.

### NULLDATA

The NULLDATA scheme, literally meaning "insignificant data," is a scheme for embedding arbitrary data on the chain. It is the fourth classic scheme and was standardized with the arrival of version 0.9.0 of Bitcoin Core in March 2014. It is based on the `OP_RETURN` instruction, whose effect is to terminate script execution and render the corresponding coin unspendable[^489]. The locking script of the scheme always begins with `OP_RETURN` and is followed by the pushed data:

``` {fontsize="\\footnotesize"}
RETURN [arbitrary data]
```

The output containing this script is exempt from the standard dust limit, which is currently 546 satoshis for P2PKH outputs, allowing it to be 0 satoshis. Moreover, due to their inherently unspendable nature, outputs can be pruned from nodes' UTXO sets. All this makes this scheme the standard means of inscribing information on the ledger.

## Types of Signatures {#types-of-signatures .unnumbered}

The programmability of Bitcoin is not only derived from its programming language but also from the signature system, which allows selecting which part of the transaction is signed. This aspect of programmability is implemented through the existence of an indicator, called the signature hash type or *sighash*, which is added to the unsigned transaction and then to the signature itself. This indicates which part of the transaction should be hashed before being submitted to the signing algorithm, hence its name.

The signature type is constructed from several signature flags that can be combined. The four existing signature flags are:

-   `SIGHASH_ALL` (`0x01`), indicating that all outputs are signed;
-   `SIGHASH_SINGLE` (`0x03`), allowing only a single output to be signed;
-   `SIGHASH_NONE` (`0x02`), indicating that no outputs are signed;
-   `SIGHASH_ANYONECANPAY` (`0x80`), allowing only a single input to be signed.

The three flags concerning outputs can be associated with `SIGHASH_ANYONECANPAY`, allowing for six different signature types in total, represented in Figure [12.6](#fig:signature-hash-types). The most frequent signature type is obviously `SIGHASH_ALL`, although some other types can occasionally be useful. Notably, `SIGHASH_ALL | SIGHASH_ANYONECANPAY` allows constructing *anyone-can-pay* transactions, whose outputs are determined but where each participant can sign their own input without knowing the others.

![The different signature types in Bitcoin.](img/signature-hash-types.png){#fig:signature-hash-types}

These flags were implemented from the beginning by Satoshi Nakamoto within the prototype. One was logically missing, which Satoshi Nakamoto probably deemed unnecessary: the one that didn't sign any inputs. However, with the development of payment channels for the Lightning Network, developers realized it could be useful. In this spirit, the `SIGHASH_NOINPUT` flag was proposed in February 2016 by Joseph Poon[^490].

This signature type could be partially implemented in BTC through BIP-118, which provides for the integration of two new flags within Taproot scripts: `SIGHASH_ANYPREVOUT` and `SIGHASH_ANYPREVOUTANYSCRIPT`. It would improve the functioning of the Lightning Network by implementing the Eltoo protocol, which relies on the construction of floating transactions.

## SegWit: The Segregated Witness {#segwit-the-segregated-witness .unnumbered}

SegWit, short for *Segregated Witness*, is a protocol upgrade that took place on Litecoin-LTC and Bitcoin-BTC in 2017. It involved separating the unlocking data of transaction inputs, such as signatures, into a separate data structure called the witness (*witness*) to eliminate transaction malleability. SegWit thus constituted a profound restructuring of transactions.

Beyond correcting malleability, SegWit brought increased transaction capacity and script versioning to facilitate future upgrades. It also improved the signing algorithm to avoid redundant hashing during verification and to make offline signing more secure.

### Malleability

SegWit originates from the problem of transaction malleability, an issue identified since January 2012. In Bitcoin, transactions are malleable in the sense that they can be slightly modified after their broadcast without becoming invalid in the eyes of the network. This property stems from the fact that a signature cannot include itself and, consequently, the unlocking script is not signed with the rest of the transaction. Malleability can thus take two forms: malleability intrinsic to the ECDSA algorithm, which is based on a random number to produce a signature (malleability by the signer); malleability arising from the form of inputs' signatures and unlocking scripts (malleability by a third party).

Malleability is not prohibitive for fund security, but it allows modifying the transaction identifier after its publication, which can be problematic in certain situations. For instance, between February 9 and 11, 2014, Mt. Gox and other exchange platforms suffered attacks exploiting this transaction malleability. Withdrawal transactions were modified by attackers, making the platforms' poorly configured software infrastructure believe that these transactions had not been confirmed. The hackers saw their accounts re-credited while simultaneously retaining the withdrawn bitcoins. These attacks led to a total loss of 64,564 bitcoins[^491].

Proposals attempted to correct malleability by a third party by constraining transaction forms as much as possible. In this spirit, BIP-62 was created in March 2014, one of whose requirements (the standard encoding of signatures described in BIP-66) was included in the consensus rules on July 4, 2015. However, these changes did not apply to malleability by the signer, creating a demand for a generalized fix.

This malleability meant that any actor participating in a multiparty signature contract could modify the transaction and thus its identifier at any time. It significantly hindered the implementation of the Lightning Network, whose payment channels, as we'll see later, rely on unpublished transactions that need to be referenced and involve multiple signatures.

The solution was to exclude the unlocking scripts from the transaction hash calculation so that a change in these scripts would not affect the identifier. This idea was initially proposed by Gregory Maxwell in August 2013 on IRC before being implemented within the alpha version of the Elements sidechain model, announced on June 8, 2015, by Blockstream. On the same day, Gregory Maxwell presented this version of Elements including *Segregated Witness* in a developer seminar in San Francisco, describing the witness as "a specific value that is a concrete proof of an existential assertion[^492]."

This solution was adapted for Bitcoin in the fall of 2015 to be applied as a soft fork. The SegWit upgrade was officially introduced to the community by developer Pieter Wuille on December 7, 2015, during the Scaling Bitcoin II conference in Hong Kong. Essentially, it involved moving the unlocking scripts to the transaction's witness. Two identifiers were then calculated: the classic identifier (`txid`), which does not include the witness, and the complete identifier (noted `wtxid` for *witness transaction identifier*), which covers the entire transaction. The complete identifiers were grouped in a second Merkle tree, the witness tree, whose root was placed in the block's coinbase transaction, ensuring all data was committed in the proof-of-work calculation. On the other hand, transactions and blocks remained valid for nodes that had not been upgraded.

SegWit has been active since August 24, 2017. The absence of the unlocking script in the calculation of the classic identifier eliminates malleability entirely, both by signers and by third parties.

### Increasing Transaction Capacity

SegWit also had the indirect effect of creating an extension block and increasing transaction capacity. Indeed, nodes following the old rules did not see the witness, so they did not count it in the block size. The question then was what limit to place on the witness.

The answer was to invent a new metric to measure the impact of transactions and blocks on the network: weight, which is a weighted average of the base size and the witness size. Expressed in weight units, it is defined as the sum of four times the base size (\(s_b\)) and the witness size (\(s_w\)):

$$
w = 4 \times s_b + s_w
$$

It follows a virtual size (\(s_v\)) defined as the sum of the base size and one-quarter of the witness size, that is: $s_v = s_b + \frac{s_w}{4}$. The block size limit became a block weight limit, which was set at 4 million units at the time of the upgrade and remained the same as of November 2023.

Thus, fees initially calculated in satoshis per byte (sat/B) have, since SegWit, been measured in satoshis per virtual byte (sat/vB). Miners select transactions based on this rate to maximize profitability relative to this limit. This effect is only valid if the limit is reached.

With SegWit, the idea is to weight the impact of inputs compared to outputs on fee calculation. If activity reaches the capacity ceiling, outputs are four times more expensive to record on-chain than the unlocking scripts contained in the inputs. The upgrade, in addition to providing a discount that encourages its use, created a disincentive to burden the UTXO set. The factor of 4 approximates material weighting[^493].

This limit of 4 million weight units is indicative. The actual block size generally does not reach 4 MB due to the shape of transactions. The data contained in normal transactions are not grouped in the witness, so they do not fully utilize the permitted block space. For example, taking a block consisting solely of transactions with 2 inputs and 2 outputs using SegWit, its actual size would be 1.784 MB[^494].

Transactions where the unlocking data are larger benefit more from this additional block space. This is the case for transactions using multisignature, such as payment channel closures. It is possible to approach the 4 MB size by maximizing the data size contained in the witness. This was done on February 1, 2023, with the creation of a 3.955 MB block whose witness was used to inscribe an image[^495].

### Script Versioning

Finally, the SegWit upgrade introduced script versioning, allowing the deployment of future upgrades. The version thus indicates which rules are applied. The first version of SegWit in 2017 used version 0, and the deployment of Taproot in 2021 was done using version 1.

There are three native output types related to SegWit for now: the P2WPKH scheme, the P2WSH scheme, and the P2TR scheme.

### P2WPKH: Pay to Witness Public Key Hash

The *Pay to Witness Public Key Hash* (P2WPKH) scheme, literally meaning "pay to the witness hash of the public key," is the first scheme implemented by SegWit. The public key hash is obtained by standard hashing (SHA-256 followed by RIPEMD-160). The apparent locking script is then:

``` {fontsize="\\footnotesize"}
<version (0)> <hash160 of the public key>
```

This script resembles an anyone-can-spend script that anyone could spend, but the interpreter adds an additional condition to prevent this. The output type is detected based on its form: the SegWit version (here 0) and the hash size (here 20 bytes). The version and hash form the essential information of the address, which is encoded using the Bech32 format and always starts with `bc1q`, such as bc1q5x9a0aqmgtrucm4l5n0y8e4kxfy9xm4udhygr2.

The unlocking script is empty. The unlocking data are contained in the transaction's witness. The part of the witness corresponding to the input is:

``` {fontsize="\\footnotesize"}
<2> <signature> <public key>
```

### P2WSH: Pay to Witness Script Hash

The *Pay to Witness Script Hash* (P2WSH) scheme, literally translated as "pay to the witness script hash," is the transcription of P2SH for SegWit. The hash of the redeem script is obtained by SHA-256 out of concern for a collision in RIPEMD-160 in the case of an address generated by multiple people[^496]. The locking script is:

``` {fontsize="\\footnotesize"}
<version (0)> <sha256 hash of the redeem script>
```

Again, this script is apparently anyone-can-spend. The output type is detected by the interpreter based on its form: the SegWit version (here 0) and the hash size (here 32 bytes). The address is again composed of these two pieces of information and encoded using the Bech32 format.

The unlocking script is empty. The unlocking data are contained in the transaction's witness. The part of the witness corresponding to the input is:

``` {fontsize="\\footnotesize"}
<number of elements + 1> [unlocking elements] <redeem script>
```

In both cases, the hash is also called the "witness program."

### Nested Types (P2SH-P2WPKH, P2SH-P2WSH)

SegWit also modified the P2SH format to include new exceptions. These exceptions correspond to the nested types (*nested*) P2SH-P2WPKH and P2SH-P2WSH. Their functioning involves including the previous locking scripts (version + hash) in a P2SH output as redeem scripts. The redeem script is then executed differently to call upon the data contained in the witness.

These nested types facilitated the transition to SegWit by allowing wallets that hadn't been updated to send funds to these addresses. Using native SegWit addresses remains more advantageous.

### P2TR: Pay to Taproot

The latest scheme to come into effect is the *Pay to Taproot* (P2TR) scheme, whose name can be translated as "pay to Taproot." This scheme allows receiving a payment to an external public key that hides a private key used to sign fund transfers, or to the root of a Merkle tree containing contract clauses (MAST). Since the payment destination is a public key, it is somewhat a return to P2PK. The locking script present in the transaction output is:

``` {fontsize="\\footnotesize"}
<version (1)> <Taproot public key>
```

The public key in question is 32 bytes in size. The version and public key constitute the elements of the address. The address is encoded using the Bech32m format, a variant of the Bech32 encoding that corrected a small bug in checksum calculation. The resulting address always starts with `bc1p`, such as bc1pqlqqhzrg60v5h87r8lugusrddgz0j306shcupthy0tdqaqurwn8qr8qsej. Unlocking the output is done with a simple signature or by executing the MAST.

All these major changes make SegWit a profound protocol upgrade that has brought many things to Bitcoin. The requirement to proceed via a soft fork explains the form it took, and it can only be understood in the context in which it was activated. However, this upgrade also brought significant drawbacks, the two main ones being the technical debt that increases the cost of maintaining and improving the code, and the weakening of overall confidentiality due to the emergence of new partially adopted address types. SegWit was therefore far from a perfect upgrade.

## Coin Mixing {#coin-mixing .unnumbered}

The fact that transactions are published on the chain leads to surveillance. As we noted earlier, it is possible to make assumptions to deduce what is really happening on the chain, assuming the user seeks to minimize the fees paid within their transactions. These heuristics (such as the co-spending heuristic, the change output heuristic, or the wallet fingerprint heuristic) form the basis of a discipline called chain analysis, which consists of cross-referencing these observations with the identification of real actors to draw conclusions about their actual economic activity. This is why the term "transparency" of the chain is sometimes used.

However, this transparency is relative, as the chain's data do not reveal individuals' identities: the system is pseudonymous in the sense that it records movements between addresses, not between people. Bitcoin's privacy model, described by Satoshi Nakamoto in the white paper in 2008, thus involves keeping secret the link between a person's identity and their addresses[^497].

![Privacy model presented in the Bitcoin white paper.](img/white-paper-privacy-model-fr.png)

This privacy model has obvious weaknesses: accidental information leaks, which always occur in digital contexts, and voluntary disclosure of the user's identity by their exchange counterpart. Therefore, no one can claim to engage in completely secret activity that entirely escapes surveillance. This is why methods exist to limit the impact of these revelations to restore one's privacy confidently.

The first measure is the one-time use of addresses. It involves generating a new private key and a new address for each incoming or outgoing payment. The benefit of this practice is to reduce the impact of identity linkage on overall privacy: as long as the address is not linked to others through on-chain activity (such as co-spending), the information leak is limited to that address alone. This good practice, mentioned in the white paper[^498], is now implemented in all good wallets.

Beyond prevention, there are also methods to correct mistakes. The best-known of these is coin mixing, which involves combining one's UTXOs with those of other users to break the deterministic links between coins and their owners' identities.

Coin mixing was originally handled by centralized mixing services, known as mixers or tumblers, which received users' bitcoins, merged them, and sent common bitcoins back to them after a certain time, preferably in the form of multiple transactions. The first mixer of this type was BitLaundry, a platform launched in September 2010 by Peter Vessenes. These services obscured the provenance of bitcoins for an external observer but not for their operators, who could also seize the bitcoins in passing, posing a dual risk.

A technique for performing this type of mixing without relying on an intermediary was developed later: CoinJoin, formally described in August 2013 by Gregory Maxwell[^499]. This method involves involving coins in a collaborative joint transaction that breaks the correspondence between inputs and some outputs. The typical transaction envisioned is one where several users each sign an input, the same number of outputs have equal amounts, and the remaining outputs form the change outputs. In this case, as illustrated in Figure [12.7](#fig:coinjoin-transaction), the change outputs are still linked to the inputs, unlike the primary outputs which are indistinguishable from each other.

![Example of a CoinJoin transaction with 5 users.](img/coinjoin-transaction-5i-10o.png){#fig:coinjoin-transaction}

These mixes rely on the notion of an "anonymity set," which measures the difficulty of linking an input to an output at a given time. We can thus obtain a forward-looking score, which is the number of possible output coins to which an input coin may correspond. In our example illustrated in Figure [12.7](#fig:coinjoin-transaction), the forward-looking score of the output at the time of the transaction is 5. If the coin had undergone a new mix (as done in Whirlpool), it would have had a forward-looking score of 9. Similarly, if one or more of the other coins had been included in a new mix, the score of the observed coin would have increased accordingly. We can also calculate a backward-looking score, corresponding to the number of potential input coins to which a particular output may be linked, assumed to be 5 in our simple transaction but which can be much higher if one or more coins have already been mixed multiple times[^500].

To manage this, the system typically uses a protocol that allows participants to connect anonymously via a coordinator without risk of information leakage or fund theft. The most well-known is ZeroLink, developed by Adam Ficsor and William Hill in August 2017, a protocol that uses David Chaum's blind signature process[^501]. In this sense, CoinJoin is sometimes referred to as Chaumian CoinJoin. A classic implementation of this idea has been realized by Whirlpool (Samourai Wallet[^502]) and Wasabi 1.0. Additionally, variants (CoinShuffle, CoinShuffle++, CashShuffle, CashFusion) have been implemented on Bitcoin variants like Decred or Bitcoin Cash. More recently, the Wasabi wallet integrated Wabisabi, which allows mixing with arbitrary output values, complicating the estimation of the privacy provided but avoiding the need to manage change outputs separately.

However, collaborative transactions are not limited to CoinJoin. For example, there is another method called PayJoin, allowing the merchant to perform a mix with the customer at the time of payment by involving one or more coins as inputs. This operation has the effect of misleading chain analysis by making an external observer believe that a single user has combined their inputs, masking the actual payment amount.

Returning to our example of Alice paying 7 mBTC to Bob by combining two coins of 6 and 2 mBTC to reach a sufficient input amount. In this case, as shown in Figure [12.8](#fig:payjoin-transaction), the application of PayJoin involves the merchant including one or more of their own coins as inputs, increasing the amount sent to the destination output accordingly, for example, 7 mBTC.

![Example of a PayJoin transaction.](img/payjoin-transaction-3i-2o.png){#fig:payjoin-transaction}

This technique was conceptualized in 2018 in several independent ways, notably through the Pay-to-EndPoint (P2EP) payment protocol and Samourai Wallet's Stowaway transactions. Their implementation occurred in 2019 for Stowaway transactions and in 2020 for P2EP.

Finally, another method aligning with the logic of coin mixing is Coinswap, a process developed by Chris Belcher that allows two or more users to exchange their coins without needing to trust each other and without this operation leaving a particular trace on the chain[^503]. However, this technique has an additional drawback in that one party inherits the entire history of the other party's coin and must assume any potential responsibility.

## Other Privacy Techniques {#other-privacy-techniques .unnumbered}

Beyond simple coin mixing to obfuscate paths an external observer might follow, there are several techniques to enhance Bitcoin's privacy. These often require modifying the base protocol and represent trade-offs, which is why they are not necessarily implemented.

These techniques were developed in the years following Bitcoin's emergence, notably on the Bitcointalk forum. Not being a cryptography academic, Satoshi Nakamoto primarily focused on the system's robustness when he designed it and did not seek to include advanced techniques. However, he was open to any proposals that would make "a much better, easier, and more convenient implementation of Bitcoin[^504]."

The first technique in this category is the ring signature process, formalized in 2001 by Ronald Rivest, Adi Shamir, and Yael Tauman. It is based on the group signature process introduced by David Chaum and Eugène van Heyst in 1991, which allowed any member of a group to sign a message on behalf of the group without an external verifier being able to identify the member, but relied on a central administrator. The ring signature innovated by not requiring an administrator, setup procedure, coordination, and not allowing a member to revoke their anonymity.

Regarding cryptocurrency, the principle is as follows: for each input coin of the transaction, the signer gathers several other coins available on the chain (called decoy outputs), uses their public keys, and signs with their private key. They also provide a key image corresponding to the coin, written on the chain, which ensures that the same coin is not spent twice. The more outputs involved in the ring, the larger the anonymity set. The trade-off is that using transaction outputs as decoys forces nodes to retain the set of these outputs since it is impossible to know which one was actually spent.

The second technique is stealth addresses, described in 2011 by Nicolas van Saberhagen and formalized in 2014 by Peter Todd for Bitcoin[^505]. It essentially uses the Elliptic Curve Diffie-Hellman key exchange scheme (ECDH) to generate one-use receiving addresses.

The basic operation is as follows. The recipient generates a private key and derives a public key they transmit as a meta-address. The sender generates an ephemeral private key, called the transaction private key, and calculates the corresponding public key. They can compute a shared secret from their private key and the other's public key (ECDH). The sender uses this secret and the recipient's public key to construct a one-use address and send funds to it, which only the recipient can spend, provided they know the transaction public key (which can be stored in a NULLDATA output). Instead of using a single key pair, the recipient can also use two so that they have separate roles: view keys and spend keys. The view private key is the only non-public element involved in constructing the address on the recipient's side and serves to identify outputs corresponding to the address in question. The spend private key is, as the name clearly indicates, used to spend the funds[^506].

If implemented externally to the protocol, this method's drawback is the need to scan the entire blockchain to know if one has received a payment. To avoid this burden, BIP-47 was proposed.

BIP-47 thus formalizes another method akin to stealth addresses, more complex, which is reusable payment codes, implemented as PayNyms in Samourai and Sparrow wallets. In this process, the payment codes of two participants allow deriving receiving addresses through key derivation. This implies they must know each other's payment codes, and at least one of these codes must remain secret. The recipient's payment code is generally public, so the sender's must be hidden. The sender transmits it encrypted in the form of a notification transaction sent to the recipient's address. This scheme's major drawback is requiring a transaction (and paying the associated fee) to add a possible recipient.

A final variant is the silent payments process, proposed in 2022 by Ruben Somsen[^507], which avoids the notification burden by using the public key of one of the transaction's inputs and reduces the chain scanning burden by limiting to the UTXO set or a subset like P2TR outputs.

The ring signature technique and stealth address process were combined in 2013 in the CryptoNote cryptocurrency concept by Nicolas van Saberhagen[^508]. In it, nodes need to retain the set of transaction outputs (since the ring signature process obscures the fact that an output has been spent), and each wallet needs to scan the set of these outputs to see if it has received a payment. Integrating stealth addresses into the protocol allows publishing the ephemeral public key directly in the transaction (making it a transaction key) and avoids the need for notification. The concept was initially implemented in the highly dubious Bytecoin in March 2014 before appearing in Monero in April of the same year, which is now its main representative, notably implementing ring signatures with 16 members.

The third privacy enhancement technique is Confidential Transactions, which hides the amounts involved in user exchanges and, logically, should rather be called Confidential Amounts. The process was described by Adam Back in 2013 and formalized by Gregory Maxwell in 2015[^509]. It requires each transaction output to contain a Pedersen commitment that binds the coin to the recipient's public key without revealing it, and a range proof, which is a zero-knowledge proof (ZKP) demonstrating the validity of the amount without disclosing it.

Confidential Transactions were added to Monero in 2017 thanks to the work of Shen Noether. RingCT, which hides exchanged amounts, was added to the protocol in January 2017 and made mandatory in September of the same year. It increased transaction sizes compared to standard transactions. However, since October 2018, this trade-off has been mitigated thanks to the implementation of bulletproofs, which reduced the burden of range proofs and allowed an 80% reduction in transaction sizes[^510].

Another concept using Confidential Transactions is Mimblewimble, proposed on August 1, 2016, by an anonymous person calling themselves Tom Elvis Jedusor in the IRC channel #bitcoin-wizards, where they shared a link to a descriptive text hosted on Tor[^511]. Mimblewimble attracted the attention of some Bitcoin developers, including mathematician Andrew Poelstra, who provided a more advanced description in a paper dated October 6, 2016[^512].

Mimblewimble's contribution is to condense the transaction history by overhauling transaction structure. It relies on three cryptographic primitives: Confidential Transactions, which hide amounts; one-way aggregate signatures (OWAS), which allow combining transactions within a block; and transaction cut-through, which allows removing intermediary transaction outputs. This reduction, which modestly improves system privacy, comes at the cost of programmability, which is directly rendered impossible.

Mimblewimble was natively implemented in the Grin system developed by Ignotus Peverell starting in October 2016 and launched on January 15, 2019. Another implementation, also launched in January 2019, was the Beam network. Mimblewimble was also integrated into Litecoin on May 20, 2022, as a soft fork of an auxiliary block called MWEB for *MimbleWimble via Extension Blocks*.

Finally, there are other anonymization techniques based on zero-knowledge proofs. The most well-known were popularized through two protocols released in 2013 and 2014 by Matthew Green and his students: Zerocoin and Zerocash[^513]. The first protocol, Zerocoin, hides fund provenance. The second protocol hides provenance, destination, and amounts using zk-SNARKs (*Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge*).

Zerocoin was implemented in Zcoin in September 2016. Starting in 2019, Zcoin gradually moved away from Zerocoin by adopting the Sigma and Lelantus protocols and became Firo in 2020. Zerocash was implemented in the Zcash system in October 2016. Using zero-knowledge proofs required a trusted setup of public parameters. While Zcoin's developers chose to use known parameters, Zcash's decided to organize an event called "The Ceremony" to generate these parameters. This ceremony took place from October 21 to 23, 2016, bringing together six participants: Andrew Miller, Peter Van Valkenburgh, Zooko Wilcox-O'Hearn, Derek Hinch, Peter Todd, and notably Edward Snowden under the pseudonym John Dobbertin[^514]. This trusted setup became unnecessary in 2022 with the integration of the Halo protocol.

In general, all these processes involve trade-offs in scalability (proofs are heavier than a simple signature), auditability (not seeing amounts implies having to fully trust the processes and their implementation), and programmability (programming coins opposes making them indistinct). This is why they have all been implemented in alternative versions of Bitcoin and not in its main version (BTC), whose community is inherently more conservative.

## A Complex Machine {#a-complex-machine .unnumbered}

Bitcoin thus forms a machine that may seem quite complex at first glance. This complexity can be explained by its objectives and the events that have marked its technical history. Its primary goal—to be money—is behind the representation of bitcoins in circulation by unspent transaction outputs, a representation that facilitates parallelization and promotes transaction confidentiality (which can be further enhanced by coin mixing and dedicated cryptographic techniques).

Moreover, Satoshi's desire to automate various mechanisms led him to integrate a true programming system within the protocol. This allows for the implementation of autonomous contracts that execute complex financial interactions between multiple participants. It also indirectly facilitates the inscription of arbitrary data on the chain. These two uses (contractual and notarial) form Bitcoin's two secondary use cases, which we will discuss in the next chapter.

[^482]: Satoshi Nakamoto, *Bitcoin: A Peer-to-Peer Electronic Cash System*, October 31, 2008.

[^483]: Satoshi Nakamoto, *Re: Transactions and Scripts: DUP HASH160 \... EQUALVERIFY CHECKSIG*, June 17, 2010, 18:46:08: <https://bitcointalk.org/index.php?topic=195.msg1611#msg1611>.

[^484]: Andreas M. Antonopoulos, "*Transactions*," in *Mastering Bitcoin: Programming the Open Blockchain*, 2nd edition, 2017, pp. 117–148.

[^485]: Gavin Andresen, *svn r197: IsStandard check for transactions*, December 7, 2010, 13:58:33 UTC: <https://bitcointalk.org/index.php?topic=2129.msg27744#msg27744>.

[^486]: Nicolas van Saberhagen (ByteCoin), *OP_EVAL proposal*, October 2, 2011, 00:49:19 UTC: <https://bitcointalk.org/index.php?topic=46538.msg553689#msg553689>.

[^487]: Gavin Andresen, *Re: OP_EVAL proposal*, October 2, 2011, 20:42:32 UTC: <https://bitcointalk.org/index.php?topic=46538.msg554620#msg554620>.

[^488]: Gavin Andresen, *BIP-16: Pay to Script Hash*, January 3, 2012: <https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki#rationale>.

[^489]: The `OP_RETURN` instruction initially returned the value at the top of the stack, hence its name. However, in July 2010, the discovery of the "*1 RETURN bug*", which allowed spending any transaction output via the unlock script `TRUE RETURN`, prompted Satoshi Nakamoto to disable this functionality by making it return `FALSE` systematically. See Satoshi Nakamoto, *reverted makefile.unix wx-config -- version 0.3.6 (git commit)*, July 29, 2010, 18:27:12 UTC: <https://sourceforge.net/p/bitcoin/code/119/>.

[^490]: Joseph Poon, *[bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness*, February 26, 2016, 01:07:46 UTC: <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012460.html>.

[^491]: For the malleability attack against Mt. Gox, see Ken Shirriff, *The Bitcoin malleability attack graphed hour by hour*, February 15, 2014: <https://www.righto.com/2014/02/the-bitcoin-malleability-attack-hour-by.html>. See also Christian Decker, Roger Wattenhofer, *Bitcoin Transaction Malleability and MtGox*, March 26, 2014: <https://arxiv.org/pdf/1403.6676.pdf>.

[^492]: SF Bitcoin Developers, *Sidechains: Bringing New Elements to Bitcoin* (video), June 8, 2015: <https://www.youtube.com/watch?v=Twynh6xIKUc>.

[^493]: SegWit Resources, *Why a discount factor of 4? Why not 2 or 8?*, January 13, 2017: <https://medium.com/segwit-co/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e>.

[^494]: A transaction with 2 inputs and 2 outputs of type P2WPKH measures 372 bytes and weighs 834 weight units at most. Thus, it's possible to include 4,796 transactions in a block, allowing us to calculate its actual size.

[^495]: See block 774,628, identifier 0000000000000000000515e202c8ae73c8155fc472422d7593af87aa74f2cf3d, whose size was 3,955,272 bytes and which included a transaction measuring 3,938,383 bytes on its own.

[^496]: Gavin Andresen, *[bitcoin-dev] Time to worry about 80-bit collision attacks or not?*, January 7, 2016, 19:02:05 UTC: <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012198.html>.

[^497]: "The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The need to publicly announce all transactions precludes this method but privacy can still be maintained by breaking the flow of information elsewhere: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else but without information linking the transaction to anyone." — Satoshi Nakamoto, *Bitcoin: A Peer-to-Peer Electronic Cash System*, October 31, 2008.

[^498]: "As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner." — Satoshi Nakamoto, *Bitcoin: A Peer-to-Peer Electronic Cash System*, October 31, 2008.

[^499]: Gregory Maxwell, *CoinJoin: Bitcoin privacy for the real world*, August 22, 2013, 02:32:31 UTC: <https://bitcointalk.org/index.php?topic=279249.msg2983902#msg2983902>.

[^500]: Loïc Morel, *Understanding and Using CoinJoin on Bitcoin*, July 19, 2022: <https://www.pandul.fr/post/comprendre-et-utiliser-le-coinjoin-sur-bitcoin>.

[^501]: Adam Ficsor (nopara73), William Hill (TDevD), *ZeroLink: The Bitcoin Fungibility Framework*, August 14, 2017: <https://github.com/nopara73/ZeroLink/tree/32ad53927a343383534bea28fffb098af65fe62a>.

[^502]: The Whirlpool mixing system and the Samourai wallet were shut down on April 24, 2024, by order of the United States Department of Justice. The co-founders of these services, Keonne Rodriguez and William Hill, were arrested the same day by authorities. — United States Attorney for the Southern District of New York, *Founders And CEO Of Cryptocurrency Mixing Service Arrested And Charged With Money Laundering And Unlicensed Money Transmitting Offenses*, April 24, 2024: <https://www.justice.gov/usao-sdny/pr/founders-and-ceo-cryptocurrency-mixing-service-arrested-and-charged-money-laundering>. (Note from January 2025.)

[^503]: Chris Belcher, *Design for a CoinSwap Implementation for Massively Improving Bitcoin Privacy and Fungibility*, May 25, 2020: <https://gist.github.com/chris-belcher/9144bd57a91c194e332fb5ca371d0964>.

[^504]: Satoshi Nakamoto, *Re: Not a suggestion*, August 11, 2010, 00:14:22 UTC: <https://bitcointalk.org/index.php?topic=770.msg8637#msg8637>.

[^505]: Nicolas van Saberhagen (ByteCoin), *Untraceable transactions which can contain a secure message are inevitable*, April 17, 2011, 02:34:24 UTC: <https://bitcointalk.org/index.php?topic=5965.msg87757#msg87757>; Peter Todd, *[Bitcoin-development] Stealth Addresses*, January 6, 2014, 12:03:38 UTC: <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/004020.html>.

[^506]: In mathematical terms, if we denote \(r\) and \(R\) as the transaction ephemeral keys, \(v\) and \(V\) as the view keys, and \(k\) and \(K\) as the spend keys, then the meta-address is \(M = (K, V)\), the shared secret is...

[^507]: Ruben Somsen, *Silent Payments*, March 13, 2022: <https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8>.

[^508]: Nicolas van Saberhagen, *CryptoNote v2.0*, October 17, 2013: <http://cryptonote.org/whitepaper.pdf>; archive: <https://web.archive.org/web/20140529235502/http://cryptonote.org/whitepaper.pdf>.

[^509]: Adam Back, *bitcoins with homomorphic value (validatable but encrypted)*, October 1, 2013, 14:19:53: <https://bitcointalk.org/index.php?topic=305791.msg3277431#msg3277431>; Gregory Maxwell, *Confidential Transactions*, 2015, archive: <https://web.archive.org/web/20150628230410/https://people.xiph.org/~greg/confidential_values.txt>.

[^510]: Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, Gregory Maxwell, *Bulletproofs: Short Proofs for Confidential Transactions and More*, 2018: <https://eprint.iacr.org/2017/1066.pdf>.

[^511]: Tom Elvis Jedusor, *Mimblewimble*, July 19, 2016, archive: <https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt>.

[^512]: Andrew Poelstra, *Mimblewimble*, October 6, 2016: <https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.pdf>.

[^513]: Ian Miers, Christina Garman, Matthew Green, Aviel D. Rubin, "*Zerocoin: Anonymous Distributed E-Cash from Bitcoin*", in *2013 IEEE Symposium on Security and Privacy*, 2013, pp. 397–411: <https://ieeexplore.ieee.org/document/6547123>; Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, Madars Virza, "*Zerocash: Decentralized Anonymous Payments from Bitcoin*", *2014 IEEE Symposium on Security and Privacy*, 2014, pp. 459–474: <https://ieeexplore.ieee.org/document/6956581>.

[^514]: Zooko Wilcox-O'Hearn, *The Design of the Ceremony*, October 26, 2016: <https://electriccoin.co/blog/the-design-of-the-ceremony/>.
