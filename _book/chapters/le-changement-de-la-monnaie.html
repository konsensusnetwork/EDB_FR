<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>10&nbsp; Le changement de la monnaie – L'Élégance de Bitcoin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/la-determination-du-protocole.html" rel="next">
<link href="../chapters/la-resistance-a-la-censure.html" rel="prev">
<link href="..//figures/freestarfish.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "Pas de résultats",
    "search-matching-documents-text": "documents trouvés",
    "search-copy-link-title": "Copier le lien vers la recherche",
    "search-hide-matches-text": "Cacher les correspondances additionnelles",
    "search-more-match-text": "correspondance de plus dans ce document",
    "search-more-matches-text": "correspondances de plus dans ce document",
    "search-clear-button-title": "Effacer",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Annuler",
    "search-submit-button-title": "Envoyer",
    "search-label": "Recherche"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="10&nbsp; Le changement de la monnaie – L’Élégance de Bitcoin">
<meta property="og:description" content="">
<meta property="og:image" content="cover.png">
<meta property="og:site_name" content="L'Élégance de Bitcoin">
<meta name="twitter:title" content="10&nbsp; Le changement de la monnaie – L’Élégance de Bitcoin">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="cover.png">
<meta name="twitter:site" content="@konsensusn">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">L’Élégance de Bitcoin</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Basculer la navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../chapters/les-debuts-de-bitcoin.html" aria-current="page"> <i class="bi bi-book" role="img" aria-label="Book">
</i> 
<span class="menu-text">Lire en ligne</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://bitcoinbook.shop/products/lelegance-de-bitcoin"> <i class="bi bi-shop" role="img" aria-label="Shop">
</i> 
<span class="menu-text">Acheter ce livre !</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Basculer la barre latérale" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/le-changement-de-la-monnaie.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Le changement de la monnaie</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Basculer la barre latérale" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Recherche" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="sidebar-tools-main">
    <div id="quarto-search" class="quarto-navigation-tool px-1" title="Recherche"></div>
</div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">À propos de ce livre</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/preface-de-jacques-favier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Préface de Jacques Favier</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/remerciements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Remerciements</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/avant-propos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Avant-propos</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-debuts-de-bitcoin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Les débuts de Bitcoin</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/une-croissance-conflictuelle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Une croissance conflictuelle</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/des-racines-monetaires.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Des racines monétaires</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-necessite-de-decentralisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">La nécessité de décentralisation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/un-mouvement-technologique.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Un mouvement technologique</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-cybermonnaie-avant-nakamoto.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">La cybermonnaie avant Nakamoto</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-valeur-de-l-information.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">La valeur de l’information</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-consensus-par-le-minage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Le consensus par le minage</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-resistance-a-la-censure.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">La résistance à la censure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-changement-de-la-monnaie.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Le changement de la monnaie</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-determination-du-protocole.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">La détermination du protocole</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-rouages-de-la-machine.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Les rouages de la machine</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-contrats-autonomes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Les contrats autonomes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-passage-a-l-echelle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Le passage à l’échelle</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/l-avenir-de-bitcoin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">L’avenir de Bitcoin</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table des matières</h2>
   
  <ul>
  <li><a href="#le-protocole" id="toc-le-protocole" class="nav-link active" data-scroll-target="#le-protocole">Le protocole</a></li>
  <li><a href="#les-implémentations-logicielles" id="toc-les-implémentations-logicielles" class="nav-link" data-scroll-target="#les-implémentations-logicielles">Les implémentations logicielles</a></li>
  <li><a href="#les-propositions-damélioration-de-bitcoin" id="toc-les-propositions-damélioration-de-bitcoin" class="nav-link" data-scroll-target="#les-propositions-damélioration-de-bitcoin">Les propositions d’amélioration de Bitcoin</a></li>
  <li><a href="#la-vérification-des-règles-de-consensus" id="toc-la-vérification-des-règles-de-consensus" class="nav-link" data-scroll-target="#la-vérification-des-règles-de-consensus">La vérification des règles de consensus</a></li>
  <li><a href="#les-hard-forks" id="toc-les-hard-forks" class="nav-link" data-scroll-target="#les-hard-forks">Les hard forks</a></li>
  <li><a href="#les-soft-forks" id="toc-les-soft-forks" class="nav-link" data-scroll-target="#les-soft-forks">Les soft forks</a></li>
  <li><a href="#lévolution-plurielle-de-bitcoin" id="toc-lévolution-plurielle-de-bitcoin" class="nav-link" data-scroll-target="#lévolution-plurielle-de-bitcoin">L’évolution plurielle de Bitcoin</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="ch:changement" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Le changement de la monnaie</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><span id="enotezch:10" label="enotezch:10"></span></p>
<p><span class="lettrine">U</span><span class="smallcaps">n</span>e monnaie est un accord concernant un moyen mutuellement acceptable dans le commerce. Cet accord peut porter sur des propriétés physiques, auquel cas le support monétaire est une marchandise, ou des propriétés numériques, auquel cas le support monétaire est un protocole informatique. Bitcoin appartient à cette seconde catégorie.</p>
<p>Par sa nature ouverte et libre, le code informatique de Bitcoin peut être copié, modifié et réutilisé à volonté. Par conséquent, le protocole (et la monnaie qu’il définit) peut lui aussi être changé, grâce à l’application d’un code différent sur le réseau. Bitcoin n’est ainsi pas un système figé qui serait géré par une autorité centrale, mais une structure ouverte qui connaît une évolution organique au cours du temps.</p>
<section id="le-protocole" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="le-protocole">Le protocole</h2>
<p>Bitcoin est par essence un protocole de communication informatique, c’est-à-dire un ensemble de règles permettant à différentes parties d’un réseau d’échanger des informations. Ce protocole permet aux nœuds du réseau pair à pair de s’échanger des transactions et des blocs et de se mettre d’accord sur le registre de propriété considéré comme correct. Le résultat est un système monétaire.</p>
<p>Bitcoin se rapproche, de façon plus ou moins manifeste, de protocoles existants. C’est par exemple le cas d’autres protocoles construits sur Internet, comme HTTP (<em>HyperText Transfer Protocol</em>) qui est utilisé pour l’affichage des pages web, SMTP (<em>Simple Mail Transfer Protocol</em>) qui est utilisé pour le courrier électronique, ou encore BitTorrent, qui permet le partage de fichiers de pair à pair. C’est également le cas des protocoles qui soutiennent Internet, appelés protocoles de la suite TCP/IP en référence aux deux premiers qui la composent&nbsp;: IP (<em>Internet Protocol</em>) qui assure la communication au niveau de la couche réseau, et TCP (<em>Transmission Control Protocol</em>) qui assure la transmission au niveau de la couche transport, en surcouche de la couche réseau.</p>
<p>Plus éloigné de Bitcoin, on peut citer la catégorie des langages de programmation. Ces langages permettent d’écrire du code (texte spécifique encodé en UTF-8), qui est transformé en fichier exécutable par un compilateur (par exemple dans le cas du C, du C++ ou du Java) ou qui est directement exécuté par un interpréteur (comme c’est le cas pour Python ou Javascript). Dans le même ordre d’idées, les langues humaines comme le français ou l’anglais sont aussi des protocoles de communication, dont les règles sont moins formelles et moins bien définies, mais qui permettent aux hommes d’échanger des informations.</p>
<p>Enfin, les monnaies peuvent être vues comme des sortes de protocole, en constituant des moyens communs de communiquer de la valeur et de formaliser l’échange économique. La monnaie se définit en particulier par le support accepté dans le commerce&nbsp;: pour une marchandise comme l’or ou l’argent, ce support est un élément chimique&nbsp;; pour la monnaie fiat, il s’agit d’un certificat émis par une autorité.</p>
<p>Dans le cas de Bitcoin, le protocole est formé de l’ensemble des règles qui permettent au réseau de communiquer et de se coordonner. Ce protocole se divise en deux parties distinctes&nbsp;: le protocole de transmission, constitué des règles de réseau, et le protocole régissant le contenu transmis, constitué des règles de consensus.</p>
<p>Les règles de réseau sont les règles qui permettent aux nœuds d’entrer en communication sur Internet. Ces règles concernent le protocole de transport sous-jacent (TCP, Tor, UDP pour FIBRE), le port réseau (8333 pour le réseau principal BTC), la procédure de découverte de pairs, la syntaxe des messages de transmission de données,&nbsp;etc. Elles peuvent différer selon les nœuds sans briser formellement le consensus&nbsp;: il suffit qu’un nœud acceptant les deux ensembles de règles fasse la liaison. De même, les nœuds sont libres de restreindre (temporairement ou définitivement) leur connexion avec un autre nœud, notamment dans le but d’éviter le spam.</p>
<p>Les règles de consensus sont les règles de construction et d’organisation des blocs et des transactions. Elles régissent la validité du registre sur lequel les membres du réseau arrivent à un accord, d’où leur nom. Ces règles sont critiques&nbsp;: un nœud qui transmettrait une transaction ou un bloc invalide aux autres nœuds verrait sa transaction ou son bloc être rejeté par le reste du réseau.</p>
<p>Les règles de consensus sont nombreuses. Certaines d’entre elles sont largement connues et explicites. En voici quelques-unes ici&nbsp;:</p>
<ul>
<li><p>Le montant en entrée d’une transaction doit être supérieur (ou égal) au montant en sortie, la différence représentant les frais collectés par le mineur&nbsp;;</p></li>
<li><p>Chaque entrée doit contenir un script de déverrouillage (contenant la ou les signatures) qui correspond au script de verrouillage (l’adresse d’envoi) de la sortie dépensée&nbsp;;</p></li>
<li><p>Une sortie transactionnelle ne peut être dépensée qu’une seule fois, en raison de l’interdiction de double dépense&nbsp;;</p></li>
<li><p>Chaque bloc doit comporter une preuve de travail, produite par hachages répétés de l’entête par la fonction SHA-256, de degré supérieur à la difficulté du réseau&nbsp;;</p></li>
<li><p>La subvention dans chaque bloc doit être inférieure à une limite, qui est divisée par deux tous les 210&nbsp;000 blocs (4 ans environ)&nbsp;;</p></li>
<li><p>La difficulté du minage est ajustée tous les 2016 blocs (2 semaines environ), de sorte à garantir un temps moyen de 10 minutes entre chaque bloc&nbsp;;</p></li>
<li><p>Le poids des blocs est limité à 4 millions d’unités de poids (telles que définies par SegWit), ce qui restreint la capacité transactionnelle du système.</p></li>
</ul>
<p>Les règles de consensus sont trop nombreuses pour être toutes explicitées. Quand elles ne le sont pas, ces règles sont implicitement définies dans l’implémentation logicielle de référence, qui est Bitcoin Core dans le cas de BTC.</p>
</section>
<section id="les-implémentations-logicielles" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="les-implémentations-logicielles">Les implémentations logicielles</h2>
<p>Les implémentations logicielles sont les programmes informatiques qui mettent en œuvre le protocole. Dans le cas des implémentations de nœud complet, la totalité des règles de consensus sont appliquées. Les implémentations peuvent également être partielles, auquel cas elles ne mettent pas en œuvre l’intégralité des règles de consensus&nbsp;: c’est par exemple le cas des portefeuilles légers, qui procèdent à une vérification simplifiée de leurs transactions.</p>
<p>Dans BTC, il existe plusieurs implémentations, dont Bitcoin Core, Libbitcoin, btcd et Bitcoin Knots. La plus connue est Bitcoin Core, qui est à la fois l’implémentation historique créée par Satoshi Nakamoto («&nbsp;<em>Satoshi client</em>&nbsp;») et reprise par Gavin Andresen en 2010, l’implémentation principale utilisée par plus de 99&nbsp;% des nœuds en novembre 2023, et l’implémentation de référence, qui définit les règles de consensus implicites.</p>
<p>D’autres protocoles possèdent des implémentations différentes. Bitcoin Cash présente une multiplicité d’implémentations dont les deux principales sont Bitcoin Cash Node (l’implémentation de référence issue de Bitcoin ABC, elle-même issue de Bitcoin Core) et Bitcoin Unlimited. Ethereum repose également sur une diversité d’implémentations, qui gèrent la transmission et la vérification des transactions (Geth, Nethermind, etc.) ou celles des blocs (Prysm, Lighthouse, etc.)</p>
<p>Une implémentation est en règle générale un logiciel libre, c’est-à-dire un logiciel dont le code est publié en accès libre sous une licence permettant l’utilisation, la modification et la reproduction. Cette caractéristique, technique et juridique, est <em>essentielle</em> à Bitcoin, car elle permet non seulement de vérifier le fonctionnement du logiciel<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, mais aussi de reprendre la main sur le code dans le cas où les développeurs iraient dans une direction non désirée.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;«&nbsp;Le code source ouvert signifie que n’importe qui peut examiner le code de manière indépendante. S’il s’agissait d’une source fermée, personne ne pourrait vérifier la sécurité. Je pense qu’il est essentiel pour un programme de cette nature d’avoir un code source ouvert.&nbsp;» – Satoshi Nakamoto, <em>Re: Questions about Bitcoin</em>, 10/12/2009 20:49:02 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=13.msg46#msg46" class="uri">https://bitcointalk.org/index.php?topic=13.msg46#msg46</a>.</p></div></div><p>L’action de copier et de modifier un logiciel est appelé un <em>fork</em> ou embranchement. Il s’agit de créer un nouveau logiciel à partir du code source d’un logiciel existant, dont l’existence découle d’une vision différente du développement de ce logiciel. Les distributions Linux sont ainsi formées de distributions antérieures. On peut aussi citer OpenOffice.org qui a donné LibreOffice et Apache OpenOffice.</p>
<p>Bitcoin Core descend directement de la première implémentation codée par Satoshi Nakamoto et partagée publiquement par ce dernier le 8 janvier 2009. Initialement appelé simplement «&nbsp;Bitcoin&nbsp;», le logiciel a été renommé bitcoind / Bitcoin-Qt en 2011, puis rebaptisé Bitcoin Core le 19 mars 2014.</p>
<p>Bitcoin Core est un logiciel codé en C++. Initialement hébergé sur SourceForge, le code est aujourd’hui présent sur GitHub<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Il est publié sous licence libre MIT, de sorte que quiconque peut le copier et le modifier à sa guise. En particulier, la licence MIT est permissive&nbsp;: elle n’empêche pas la réutilisation du code comme partie ou comme base d’un logiciel soumis à une licence privative. Cette licence a été choisie par Satoshi, au détriment de la licence GPL, en raison de sa compatibilité avec les autres licences<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;<em>Bitcoin Core integration/staging tree</em>&nbsp;: <a href="https://github.com/bitcoin/bitcoin" class="uri">https://github.com/bitcoin/bitcoin</a>.</p></div><div id="fn3"><p><sup>3</sup>&nbsp;Satoshi Nakamoto, <em>Re: Switch to GPL</em>, 12/09/2010 19:24:53 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=989.msg12494#msg12494" class="uri">https://bitcointalk.org/index.php?topic=989.msg12494#msg12494</a>.</p></div></div><p>Le développement de Bitcoin Core se fait de manière ouverte et méritocratique. Le dépôt GitHub est ouvert à tous et n’importe qui peut contribuer au maintien et à l’amélioration du logiciel en faisant une demande de modification du code (<em>pull request</em>). Les contributeurs fréquents sont appelés des «&nbsp;<em>core developers</em>&nbsp;». Pour faciliter le développement, les contributeurs communiquent par différents moyens, mais les deux principaux sont le canal IRC bitcoin-core-dev où ont lieu la plupart des discussions et la liste de diffusion bitcoin-dev.</p>
<p>Toutefois, Bitcoin Core dispose d’une certaine hiérarchie. Le dépôt est en effet géré par des mainteneurs qui sont responsables de fusionner les demandes de modification créées par les contributeurs. L’inclusion dans le code dépend ainsi de différents critères évalués par ces mainteneurs, comme l’utilité démontrable du changement, le format correct suivant les lignes directrices du projet, la revue par les pairs ou la réputation du contributeur<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;«&nbsp;Les mainteneurs prendront en considération un correctif s’il est en accord avec les principes généraux du projet&nbsp;; s’il répond aux normes minimales d’inclusion&nbsp;; et jugeront du consensus général des contributeurs.&nbsp;» – <em>Contributing to Bitcoin Core</em>, 26 mai 2023&nbsp;: <a href="https://github.com/bitcoin/bitcoin/blob/25.x/CONTRIBUTING.md" class="uri">https://github.com/bitcoin/bitcoin/blob/25.x/CONTRIBUTING.md</a>.</p></div><div id="fn5"><p><sup>5</sup>&nbsp;Wladimir J. van der Laan, <em>The widening gyre</em>, 21 janvier 2021, archive&nbsp;: <a href="https://web.archive.org/web/20210121201607/https://laanwj.github.io/2021/01/21/decentralize.html" class="uri">https://web.archive.org/web/20210121201607/https://laanwj.github.io/2021/01/21/decentralize.html</a>&nbsp;; Wladimir J. van der Laan, <em>Remove laanwj from trusted-keys (git commit)</em>, 07/02/2023 09:12 UTC&nbsp;: <a href="https://github.com/bitcoin/bitcoin/commit/aafa5e945cef7a4f65ddadcf548932dd4e27ada1" class="uri">https://github.com/bitcoin/bitcoin/commit/aafa5e945cef7a4f65ddadcf548932dd4e27ada1</a>.</p></div></div><p>La charge du logiciel était initialement allouée à un mainteneur principal, qui avait pour rôle de nommer les mainteneurs normaux, de décider du cycle de sortie du logiciel, de fusionner l’ensemble des modifications et de modérer les débats. Cette mission était assurée au début par Satoshi Nakamoto qui s’occupait d’intégrer les contributions sur le dépôt SourceForge. Puis, le 23 février 2011, Satoshi a transmis la responsabilité à Gavin Andresen, avant de disparaître définitivement. Gavin s’est ensuite chargé du projet pendant plus de trois ans avant de laisser sa place à Wladimir J. van der Laan le 7 avril 2014. Enfin, le 7 février 2023, ce dernier a démissionné après neuf ans de service. La fonction de mainteneur principal a alors été supprimée et remplacée par la responsabilité collective des mainteneurs<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>En novembre 2023, les mainteneurs de Bitcoin Core étaient au nombre de cinq&nbsp;: Michael Ford, Hennadii Stepanov, Andrew Chow, Gloria Zhao et Ryan Ofsky. Ils suivent la voie de mainteneurs emblématiques (hors mainteneurs principaux) comme Martti Malmi, Laszlo Hanyecz, Chris Moore, Pieter Wuille, Jeff Garzik, Nils Schneider, Gregory Maxwell, Jonas Schnelli, Samuel Dobson ou Marco Falke. Parmi les contributeurs actifs qui n’ont jamais été mainteneurs, on retrouve Matt Corallo, practicalswift, Luke-Jr et John Newbery. Les empreintes PGP des mainteneurs sont disponibles publiquement sur le dépôt.</p>
<p>Ce fonctionnement ouvert donne au logiciel une sûreté plus grande que la plupart des programmes informatiques. En effet, au vu des sommes en jeu, la récompense pour l’exploitation réussie d’une faille majeure serait énorme, si bien qu’on peut supposer qu’une telle faille n’a pas été découverte. S’il y a effectivement des vulnérabilités dans le logiciel, celles-ci sont très rares et très subtiles, de sorte qu’elles sont généralement découvertes par des développeurs bienveillants, à l’instar du développeur Awemany qui avait, en septembre 2018, divulgué de manière responsable une faille inflationniste dans le code<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. Ainsi, le passage du temps renforce la confiance qu’on peut avoir dans le logiciel (ainsi que dans le système) conformément à l’effet Lindy<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Awemany, <em>600 Microseconds</em>, 21 septembre 2018&nbsp;: <a href="https://medium.com/@awemany/600-microseconds-b70f87b0b2a6" class="uri">https://medium.com/@awemany/600-microseconds-b70f87b0b2a6</a>.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;Comme le faisait remarquer Hal Finney en 2011&nbsp;: «&nbsp;Chaque jour qui passe sans que Bitcoin ne s’effondre en raison de problèmes juridiques ou techniques apporte de nouvelles informations au marché. Cela augmente les chances de succès de Bitcoin et justifie un prix plus élevé.&nbsp;» – Hal Finney, <em>Re: Bitcoin and the Efficient Market Hypothesis</em>, 04/06/2011 23:36:04 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=11765.msg169026#msg169026" class="uri">https://bitcointalk.org/index.php?topic=11765.msg169026#msg169026</a>.</p></div></div></section>
<section id="les-propositions-damélioration-de-bitcoin" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="les-propositions-damélioration-de-bitcoin">Les propositions d’amélioration de Bitcoin</h2>
<p>Les implémentations peuvent être mises à jour par leurs développeurs, auquel cas elles ont chacune leur modèle de décision. Dans Bitcoin Core, comme on l’a dit, tout le monde peut proposer une modification du code mais le dernier mot est laissé aux développeurs. De même, les changements internes liés aux portefeuilles sont gérés par leurs développeurs propres.</p>
<p>Il existe néanmoins une façon de proposer des modifications pouvant s’appliquer à toutes les implémentations&nbsp;: les propositions d’amélioration de Bitcoin (en anglais <em>Bitcoin Improvement Proposals</em> ou BIP), qui sont des documents décrivant des changements possibles du protocole ou fournissant des informations générales à la communauté. Ce système des BIP a été formalisé par Amir Taaki en 2011, sur la base des <em>Python Enhancement Proposals</em> (PEP) qui servent à améliorer le langage de programmation Python. Initialement défini par le BIP-1, le procédé est aujourd’hui décrit par le BIP-2, rédigé par Luke-Jr.&nbsp;Il est hébergé sur un dépôt GitHub géré par Bitcoin Core.</p>
<p>Les BIP peuvent être répartis en trois types&nbsp;: le BIP de suivi de standard (<em>standards track BIP</em>), qui concerne les changements qui affectent la plupart ou toutes les implémentations de Bitcoin&nbsp;; le BIP informationnel (<em>informational BIP</em>), qui décrit un problème dans la conception de Bitcoin ou donne des directives générales ou des informations à la communauté de Bitcoin, mais ne propose pas de nouvelle fonctionnalité&nbsp;; le BIP de procédure (<em>process BIP</em>), qui décrit une procédure ou un changement de procédure à adopter. Les BIP de suivi de standard sont les plus courants. Ils peuvent concerner différents aspects&nbsp;: les règles de consensus, le protocole de transmission (<em>Peer Services</em>), l’interface logicielle (<em>API/RPC</em>) ou les conventions utilisées dans les applications<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;Eric Lombrozo, <em>BIP-123: BIP Classification</em>, 26 août 2015&nbsp;: <a href="https://github.com/bitcoin/bips/blob/master/bip-0123.mediawiki" class="uri">https://github.com/bitcoin/bips/blob/master/bip-0123.mediawiki</a>.</p></div></div><p>Avant d’être adopté, un BIP doit passer par de nombreuses étapes. D’abord, il est assigné à un ou plusieurs auteurs qui se chargent d’en rédiger une première version respectant le format défini et prenant en compte l’état de l’art correspondant. Puis, le BIP est partagé dans la communauté des développeurs de Bitcoin, généralement par l’intermédiaire de la liste de diffusion de développement (bitcoin-dev). Les discussions ont lieu sur cette mailing list. Ensuite, le BIP est officiellement proposé au système sous la forme d’une demande de modification du code (<em>pull request</em>) sur le dépôt GitHub, qui doit être approuvée par l’éditeur désigné par Bitcoin Core (Luke-Jr depuis 2016). Enfin, un numéro lui est assigné et il est intégré au dépôt sous la forme d’une ébauche. Il peut par la suite changer de statut au cours du temps, selon l’adoption de la communauté, l’objectif étant qu’il devienne définitif ou actif.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/bip-process-fr.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Schéma de la procédure d’adoption d’un BIP, inspiré du BIP-1."><img src="img/bip-process-fr.png" class="img-fluid figure-img" alt="Schéma de la procédure d’adoption d’un BIP, inspiré du BIP-1."></a></p>
<figcaption>Schéma de la procédure d’adoption d’un BIP, inspiré du BIP-1.</figcaption>
</figure>
</div>
<p>Notez que ces documents sont utilisés pour BTC mais également pour d’autres protocoles. Par exemple, les BIP décrivant le fonctionnement des portefeuilles (BIP-32, BIP-39, BIP-44) sont valides pour la grande majorité des cryptomonnaies. Le SLIP-44 recense les cryptomonnaies compatibles avec le BIP-44. Les autres protocoles cryptoéconomiques disposent même parfois de leurs propres systèmes de propositions. Ethereum utilise les EIP (<em>Ethereum Improvement Proposals</em>), Bitcoin Cash les CHIP (<em>Cash Improvement Proposals</em>), Litecoin les LIP, etc.</p>
</section>
<section id="la-vérification-des-règles-de-consensus" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="la-vérification-des-règles-de-consensus">La vérification des règles de consensus</h2>
<p>Bitcoin se base sur un réseau public d’ordinateurs accessible librement sur Internet. Ce réseau suit un modèle pair à pair, c’est-à-dire un modèle dans lequel tous les membres du réseau, appelés des nœuds, possèdent les mêmes privilèges. Ce sont ces nœuds qui s’assurent que les règles de consensus sont respectées. Si un bloc est invalide (en contenant une transaction invalide par exemple), alors il est rejeté par les nœuds appliquant les règles.</p>
<p>Dans Bitcoin, le rôle des nœuds est d’entretenir une copie du registre des transactions (la fameuse chaîne de blocs) et, ce faisant, de s’assurer de la validité des transactions et des blocs. Pour cela, ils communiquent avec les autres nœuds du réseau et relaient les nouvelles transactions et les nouveaux blocs, qui émanent respectivement des utilisateurs et des mineurs.</p>
<p>La vérification des règles de consensus peut être complète. Dans ce cas, on utilise parfois le pléonasme «&nbsp;nœuds complets&nbsp;» ou «&nbsp;<em>full node</em>&nbsp;» pour insister sur le fait qu’ils vérifient l’intégralité de la chaîne. Ils téléchargent l’intégralité de la chaîne de blocs, vérifient les règles de consensus et relaient les blocs et les transactions. C’est une charge, que ce soit au niveau de la conservation des données (en novembre 2023, la chaîne de Bitcoin pesait environ 530&nbsp;Go de données et l’ensemble des UTXO plus de 8,5&nbsp;Go) que de la bande passante (la taille moyenne des blocs minés toutes les 10 minutes gravitait autour de 1,7&nbsp;Mo en novembre 2023).</p>
<p>Les nœuds réduits (<em>pruned nodes</em>), qui conservent l’état du réseau mais pas l’entièreté de la chaîne, sont des nœuds à part entière puisqu’ils ont vérifié la conformité des règles sur l’intégralité de la chaîne. Ils ne sont juste pas en mesure d’accéder à l’historique de la chaîne précédant une certaine date.</p>
<p>La vérification peut aussi être partielle, auquel cas on parle de client léger (ou de «&nbsp;nœud léger&nbsp;» par abus de langage). Cela est utile pour les personnes qui n’ont pas l’intérêt de faire tourner un nœud complet. C’est par exemple le cas dans les logiciels de hachage (mettant en œuvre Stratum) et dans les portefeuilles légers. Ils utilisent en particulier une méthode conceptualisée dans le livre blanc de Bitcoin en 2008&nbsp;: la vérification de paiement simplifiée<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;Satoshi Nakamoto décrivait la vérification de paiement simplifiée comme suit&nbsp;: «&nbsp;Il est possible de vérifier les paiements sans faire fonctionner un nœud complet du réseau. Un utilisateur a seulement besoin de conserver une copie des entêtes des blocs de la plus longue chaîne de preuves de travail, qu’il peut obtenir en interrogeant les nœuds du réseau jusqu’à ce qu’il soit convaincu qu’il possède la plus longue chaîne, et obtenir la branche de Merkle liant la transaction au bloc dans lequel elle est horodatée. Il ne peut pas vérifier la transaction par lui-même, mais en la reliant à un endroit de la chaîne, il peut voir qu’un nœud du réseau l’a acceptée, et les blocs ajoutés après le confirment.&nbsp;» – Satoshi Nakamoto, <em>Bitcoin: A Peer-to-Peer Electronic Cash System</em>, 31 octobre 2008.</p></div></div><p>La vérification de paiement simplifiée (nommée en anglais <em>Simplified Payment Verification</em> et abrégée en SPV) est une méthode astucieuse, qui permet aux utilisateurs néophytes et occasionnels de pouvoir interagir facilement avec le protocole sans devoir gérer un nœud complet, ni devoir faire aveuglément confiance à un dépositaire. Elle permet de réduire considérablement la charge des portefeuilles légers.</p>
<p>La vérification de paiement simplifiée se fonde sur la façon dont les blocs de transactions sont chaînés et structurés comme nous avons pu le voir dans le chapitre&nbsp;<a href="le-consensus-par-le-minage.html" data-reference-type="ref" data-reference="ch:confirmation">8</a>. Premièrement, la chaîne de preuve de travail n’est pas à proprement parler une chaîne de blocs, mais une chaîne d’entêtes. Cela fait que les clients légers n’ont qu’à conserver cette chaîne des entêtes pour déterminer la chaîne possédant le plus de travail accumulé. Puisque chaque entête pèse 80 octets, la taille des données à conserver reste modeste pour des appareils modernes&nbsp;: elle augmente d’environ 4&nbsp;Mio par an, ce qui représentait un peu plus de 62 Mio en novembre 2023.</p>
<p>Deuxièmement, les transactions sont agencées dans un arbre de Merkle, de sorte que les clients légers peuvent se contenter de demander les informations liées à la branche qui les intéresse pour s’assurer de la confirmation d’une de leurs transactions. Le nombre d’empreintes à obtenir et de hachages à effectuer dépend du logarithme binaire (<span class="math inline">\(\log_{2}\)</span>) du nombre de transactions présentes dans le bloc. Pour un bloc de 3&nbsp;000 transactions (moyenne haute sur BTC), la charge correspond à demander 12 empreintes de 32 octets et à calculer 12 hachages pour procéder à la vérification.</p>
<p>Cette vérification simplifiée permet d’alléger la charge des portefeuilles, mais elle présente des défauts majeurs. D’abord, elle manque de fiabilité&nbsp;: les nœuds ne peuvent pas mentir en inventant une transaction, mais peuvent omettre de transmettre des informations nécessaires. Ce défaut peut être partiellement contrebalancé en augmentant la diversité des connexions sur le réseau. Cependant, même dans ce cas, la vérification est vulnérable si la chaîne est attaquée par une entité disposant de la puissance de calcul majoritaire<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;Ce cas a été décrit par Satoshi Nakamoto dans le livre blanc&nbsp;: «&nbsp;De ce fait, la vérification est fiable tant que les nœuds honnêtes contrôlent le réseau, mais est plus vulnérable si le réseau est maîtrisé par un attaquant. Alors que les nœuds du réseau peuvent vérifier les transactions par eux-mêmes, la méthode simplifiée peut être trompée par des transactions forgées par l’attaquant aussi longtemps que celui-ci maîtrise le réseau. Une stratégie pour se protéger serait d’accepter les alertes des nœuds du réseau lorsqu’ils détectent un bloc invalide, invitant le logiciel de l’utilisateur à télécharger le bloc complet et les transactions suspectes pour confirmer l’incohérence. Les entreprises qui reçoivent fréquemment des paiements voudront probablement toujours faire fonctionner leurs propres nœuds afin d’obtenir une sécurité plus indépendante et une vérification plus rapide.&nbsp;» – Satoshi Nakamoto, <em>Bitcoin: A Peer-to-Peer Electronic Cash System</em>, 31 octobre 2008.</p></div><div id="fn11"><p><sup>11</sup>&nbsp;Une première façon de remédier au problème de confidentialité était de mettre en place des filtres de Bloom, tels que décrits dans le BIP-37, mais cette méthode était peu efficace. Voir Arthur Gervais, Srdjan Capkun, Ghassan O. Karame, Damian Gruber, «&nbsp;<em>On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients</em>&nbsp;», in <em>Proceedings of the 30th Annual Computer Security Applications Conference</em>, décembre 2014, pp.&nbsp;326—335&nbsp;: <a href="https://eprint.iacr.org/2014/763.pdf" class="uri">https://eprint.iacr.org/2014/763.pdf</a>. Il existe également Neutrino, décrit dans le BIP-157 et le BIP-158, qui fait usage du codage de Golomb-Rice et demande une plus grande bande passante.</p></div></div><p>Ensuite, la vérification simplifiée possède aussi une insuffisance de confidentialité, car le client doit dévoiler une partie de son activité transactionnelle par les requêtes réalisées auprès des nœuds du réseau. Une façon de corriger partiellement ce problème est d’accroître le nombre d’informations demandées pour dissimuler les informations essentielles, mais cette méthode est plus qu’imparfaite<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p>
<p>Enfin, elle présente un défaut de vérification, en étant par définition partielle. Toutes les règles de consensus ne sont pas vérifiées, ce qui fait que les nœuds complets peuvent convenir d’un changement de règle qui ne sera pas remarqué par le client léger. Par exemple, les clients SPV ne vérifient pas les contraintes appliquées sur la taille des blocs, et le réseau pourrait donc subir une modification de cette limite sans qu’ils s’en rendent compte. C’est ce qui explique la stratégie des promoteurs de SegWit2X en 2017, qui prévoyaient de doubler la taille limite des blocs sans protection contre la rediffusion afin que les portefeuilles à vérification de paiement simplifiée suivent simplement la chaîne la plus longue.</p>
<p>Satoshi pensait que le système pourrait perdurer avec une vérification centralisée entre les mains de quelques nœuds vérificateurs (dont les mineurs) et que le reste des utilisateurs ferait usage des clients légers. Dans sa première réponse à James A. Donald en novembre 2008, il indiquait ainsi&nbsp;:</p>
<p>«&nbsp;Bien avant que le réseau n’atteigne cette taille, les utilisateurs pourront utiliser la vérification de paiement simplifiée (section 8) pour contrôler les doubles dépenses, ce qui ne nécessite que la chaîne des entêtes de bloc, soit environ 12&nbsp;Ko par jour. Seules les personnes essayant de créer de nouvelles pièces auront besoin de faire fonctionner des nœuds de réseau<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>.&nbsp;»</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;Satoshi Nakamoto, <em>Re: Bitcoin P2P e-cash paper</em>, 03/11/2008, 01:37:43 UTC&nbsp;: <a href="https://www.metzdowd.com/pipermail/cryptography/2008-November/014815.html" class="uri">https://www.metzdowd.com/pipermail/cryptography/2008-November/014815.html</a>.</p></div></div><p>En cela, il se trompait. La vérification des règles de consensus a besoin d’être intégrale pour que celles-ci soient appliquées.</p>
<p>C’est donc au niveau du nœud complet que se joue cette vérification, une réalité qui est parfois retranscrite par l’adage «&nbsp;pas ton nœud, pas tes règles<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>&nbsp;». Ne faites pas confiance, vérifiez&nbsp;! Un peu comme une langue résulte des choix que font ses locuteurs, un protocole informatique résulte des règles appliquées par les nœuds complets. Cette vérification joue donc un rôle crucial dans la détermination du protocole.</p>
<div class="no-row-height column-margin column-container"><div id="fn13"><p><sup>13</sup>&nbsp;Understanding Bitcoin, <em>Not Your Node Not Your Rules! w/ Ketominer, Udi Wertheimer, Francis Pouliot &amp; Mir Liponi</em> (vidéo), 5 avril 2019&nbsp;: <a href="https://www.youtube.com/watch?v=jwaKVIEm-rI" class="uri">https://www.youtube.com/watch?v=jwaKVIEm-rI</a>.</p></div></div></section>
<section id="les-hard-forks" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="les-hard-forks">Les hard forks</h2>
<p>Puisque Bitcoin est ouvert et libre, les règles de consensus peuvent être modifiées à volonté par les nœuds du réseau au moyen d’un changement d’acceptation des blocs et des transactions. Ces modifications peuvent mener à des conflits sur le réseau, et éventuellement à la séparation en deux réseaux distincts gérant chacun sa propre chaîne et sa propre monnaie. D’où l’utilisation du mot <em>fork</em>, qui signifie «&nbsp;embranchement&nbsp;», «&nbsp;bifurcation&nbsp;» ou «&nbsp;fourche&nbsp;» en français, pour parler de ce phénomène.</p>
<p>Les modifications des règles de consensus sont couramment rangées en deux catégories&nbsp;: celle des <em>hard forks</em>, qui constituent des mises à niveau brutes et incompatibles, et celle des <em>soft forks</em>, qui présentent une certaine rétrocompatibilité. Voyons comment ces changements se manifestent, en commençant par les hard forks, avant de décrire les soft forks.</p>
<p>Dans Bitcoin, il existe une polysémie au sujet du mot <em>fork</em>, qui possède quatre significations différentes&nbsp;: le fork logiciel, le fork de règles de consensus, le fork de chaîne commun et le fork de chaîne persistant. Cette polysémie prête à confusion de sorte qu’on préfère utiliser un terme différent pour chacun de ces sens.</p>
<p>Comme on l’a dit, le mot fork est d’abord utilisé dans le développement logiciel, notamment dans le cadre du logiciel libre qui autorise et encourage ce type de pratique. Il désigne la création d’un programme dérivé du code source d’un programme existant et aussi, par abus de langage, le programme dérivé en lui-même. En ce sens, l’implémentation de référence peut subir un embranchement, créant un logiciel alternatif. Ce logiciel peut respecter les règles de consensus (comme par exemple Bitcoin Knots), mais il peut aussi les faire dévier, en créant un nouveau protocole qui partage l’historique de la chaîne (Bitcoin ABC, devenu Bitcoin Cash Node) ou non (Litecoin).</p>
<p>Le fork peut ensuite désigner l’embranchement commun de la chaîne de blocs, par analogie avec le développement logiciel. La chaîne de blocs n’est en effet pas une structure linéaire, mais une «&nbsp;structure en forme d’arbre<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>&nbsp;» qui peut posséder de multiples branches de blocs, pareillement compatibles avec les règles de consensus acceptées par le réseau, la sélection de la branche correcte se faisant par la plus longue (possédant le plus de travail accumulé). Ce type d’embranchement se produit régulièrement dans Bitcoin de manière tout à fait normale et bénigne, lorsque deux mineurs trouvent simultanément un bloc différent de leur côté, et est résolu lorsqu’un nouveau bloc est trouvé.</p>
<div class="no-row-height column-margin column-container"><div id="fn14"><p><sup>14</sup>&nbsp;Satoshi Nakamoto, code source de la version 0.1 du logiciel Bitcoin&nbsp;: <a href="https://github.com/trottier/original-bitcoin/blob/4184ab26345d19e87045ce7d9291e60e7d36e096/src/main.h#L1001-L1008" class="uri">https://github.com/trottier/original-bitcoin/blob/4184ab26345d19e87045ce7d9291e60e7d36e096/src/main.h#L1001-L1008</a>.</p></div></div><p>Le fork peut aussi se rapporter à une scission de la chaîne de blocs causée par une incompatibilité des règles de consensus. On parle alors de hard fork ou d’«&nbsp;embranchement divergent&nbsp;». Cette scission est généralement permanente dans le sens où les deux branches ne peuvent pas se réconcilier par le mécanisme de consensus de Nakamoto, sauf dans un cas très précis&nbsp;: si les règles de la branche majoritaire forment une sous-partie restrictive des règles de la branche minoritaire. Les deux chaînes résultantes sont, à terme, vouées à exister sur des réseaux séparés.</p>
<p>Enfin, le terme fork peut, par métonymie, désigner une modification des règles de consensus, qui est toujours susceptible de provoquer une scission de chaîne et une séparation du réseau. Une restriction des règles de consensus est appelée un soft fork, ou «&nbsp;embranchement convergent&nbsp;», en vertu de sa capacité à résulter en une branche unique. Toute autre modification des règles de consensus, qu’il s’agisse d’une extension ou d’une modification strictement incompatible, est appelée un hard fork, en référence à sa propension à créer une scission de chaîne. C’est de ces deux modifications dont nous voulons parler ici<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn15"><p><sup>15</sup>&nbsp;Notez que les concepts sont liés. Ainsi, un fork logiciel (copie et modification) peut implémenter un fork des règles de consensus (hard fork ou soft fork) qui finira par créer un fork persistant de la chaîne (scission).</p></div><div id="fn16"><p><sup>16</sup>&nbsp;David François (davout), <em>Re: Small protocol changes for flexibility</em>, 07/12/2010 15:08:02 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=894.msg27757#msg27757" class="uri">https://bitcointalk.org/index.php?topic=894.msg27757#msg27757</a>.</p></div></div><p>Le hard fork est le concept le plus ancien si on le compare au soft fork. Il était auparavant qualifié de «&nbsp;changement incompatible<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>&nbsp;». Le hard fork est une modification non restrictive des règles de consensus. Il provoque un conflit sur le réseau entre les nœuds qui appliquent les anciennes règles et les nœuds qui appliquent les nouvelles.</p>
<p>Un hard fork peut être extensif, c’est-à-dire élargir les règles de consensus sur les blocs et les transactions. Les anciens peuvent ainsi produire des blocs valides sur la nouvelle chaîne, mais pas l’inverse. L’exemple typique de ce genre de hard fork est l’augmentation de la taille limite des blocs, qui consiste à accepter des blocs ayant une taille ou un poids plus grand, comme 2&nbsp;Mo au lieu de 1&nbsp;Mo ou 8&nbsp;MWU à la place de 4&nbsp;MWU. Ce hard fork extensif est illustré sur la figure&nbsp;<a href="#fig:expanding-hard-fork" data-reference-type="ref" data-reference="fig:expanding-hard-fork">10.1</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/expanding-hard-fork-induced-forks.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Schéma d’un hard fork extensif&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, les deux chaînes persistent&nbsp;; dans le cas contraire, seule la deuxième survit."><img src="img/expanding-hard-fork-induced-forks.png" class="img-fluid figure-img" alt="Schéma d’un hard fork extensif&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, les deux chaînes persistent&nbsp;; dans le cas contraire, seule la deuxième survit."></a></p>
<figcaption>Schéma d’un hard fork extensif&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, les deux chaînes persistent&nbsp;; dans le cas contraire, seule la deuxième survit.</figcaption>
</figure>
</div>
<p>Dans le cas où le hard fork extensif n’est pas soutenu par une majorité de la puissance de calcul du réseau, celui-ci risque de ne pas créer une branche persistante. Par exemple, les blocs de la branche imposant une limite de taille plus petite sont entièrement compatibles avec les nouvelles règles, de sorte que, si elle est plus longue, c’est elle qui sera sélectionnée comme la branche correcte. C’est pour éviter cette situation problématique que les hard forks sont généralement bilatéraux.</p>
<p>Le hard fork bilatéral est un hard fork qui crée une incompatibilité totale entre les nouvelles règles et les anciennes. Il peut s’agir d’une règle ajoutée comme l’exigence que le premier bloc de l’embranchement inclue un changement incompatible. Dans notre cas de l’augmentation de la taille limite des blocs, il s’agirait d’imposer au premier bloc d’être strictement plus gros que la taille limite précédente, comme on le voit sur la figure&nbsp;<a href="#fig:expanding-hard-fork-failure" data-reference-type="ref" data-reference="fig:expanding-hard-fork-failure">10.2</a>. Cette règle supplémentaire est appelée protection contre la destruction par recoordination (ou <em>wipeout protection</em> en anglais).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/bilateral-hard-fork-induced-fork.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Schéma d’un hard fork bilatéral&nbsp;: les nouvelles règles sont strictement incompatibles avec les anciennes règles, de sorte que les deux chaînes persistent."><img src="img/bilateral-hard-fork-induced-fork.png" class="img-fluid figure-img" alt="Schéma d’un hard fork bilatéral&nbsp;: les nouvelles règles sont strictement incompatibles avec les anciennes règles, de sorte que les deux chaînes persistent."></a></p>
<figcaption>Schéma d’un hard fork bilatéral&nbsp;: les nouvelles règles sont strictement incompatibles avec les anciennes règles, de sorte que les deux chaînes persistent.</figcaption>
</figure>
</div>
<p>Un autre exemple est le changement de l’algorithme de signature des transactions, qui rend l’intégralité des transactions signées et des blocs non vides strictement incompatibles. Ce changement a pour effet de permettre en plus une protection contre la rediffusion des transactions (<em>replay protection</em>), dans le cas où deux chaînes concurrentes persisteraient.</p>
<p>Deux situations peuvent découler d’un hard fork&nbsp;: soit la quasi-totalité de l’économie procède au changement, auquel cas une seule chaîne subsiste&nbsp;; soit l’économie se fragmente, auquel cas les deux chaînes persistent. La première situation est visée par le hard fork de mise à niveau qui n’a pas vocation à créer deux chaînes distinctes. La seconde est désirée par le hard fork contentieux, résultant d’une division de la communauté au sujet du changement. Le hard fork accidentel, créé par une modification non désirée des règles de consensus implicites, est écarté ici<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;Le 11 mars 2013, le passage de la version 0.7 du logiciel à la version 0.8 implémentait la migration du système de base de données de Berkeley DB à LevelDB. Toutefois, il s’avérait que Berkeley DB faisait intervenir une limite par défaut (<em>lock limit</em>) qui n’était pas présente dans LevelDB. Par conséquent, la migration constituait un hard fork accidentel et a provoqué un embranchement à partir du bloc 225&nbsp;430 qui a duré environ 6 heures. La décision a finalement été prise de revenir à la version 0.7, invalidant la branche de 24 blocs minée du côté de la version 0.8, et de procéder à la migration quelques mois plus tard. – Voir Vitalik Buterin, «&nbsp;<em>Bitcoin Network Shaken by Blockchain Fork</em>&nbsp;», <em>Bitcoin Magazine</em>, 13 mars 2013&nbsp;: <a href="https://bitcoinmagazine.com/technical/bitcoin-network-shaken-by-blockchain-fork-1363144448" class="uri">https://bitcoinmagazine.com/technical/bitcoin-network-shaken-by-blockchain-fork-1363144448</a>&nbsp;; et Gavin Andresen, <em>BIP-50: March 2013 Chain Fork Post-Mortem</em>, &nbsp;: <a href="https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki" class="uri">https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki</a>.</p></div></div><p>Le hard fork de mise à niveau est un hard fork qui nécessite une synchronisation de la quasi-totalité de la communauté. Il résulte généralement en une seule chaîne, de sorte qu’on peut considérer que le protocole a été mis à niveau, alors qu’il s’agit essentiellement d’une utilisation économique qui passe d’un protocole à un autre. Il peut pour cela être extensif, même si la bilatéralité est préférée pour des raisons de sécurité.</p>
<p>Le premier hard fork de mise à niveau connu est probablement l’ajout des codes opération <code>OP_NOP</code> à la version 0.3.6 de Bitcoin par Satoshi Nakamoto en juillet 2010. L’augmentation de la taille des blocs était également pensée comme un hard fork de mise à niveau, notamment par Satoshi lui-même<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>, jusqu’au hard fork contentieux de Bitcoin Cash en 2017.</p>
<div class="no-row-height column-margin column-container"><div id="fn18"><p><sup>18</sup>&nbsp;En octobre 2010, à la suite de la proposition de Jeff Garzik d’augmenter la limite directement à 7,168&nbsp;Mo afin d’«&nbsp;égaler le taux transactionnel moyen de PayPal&nbsp;», Satoshi – bien conscient qu’il s’agissait d’un correctif «&nbsp;incompatible avec le réseau&nbsp;» – écrivait&nbsp;: «&nbsp;[La mise à niveau] peut être introduite progressivement, par exemple&nbsp;: if (blocknumber &gt; 115000) maxblocksize = largerlimit. Elle peut commencer à être intégrée dans les versions bien avant, de sorte qu’au moment où elle atteint le numéro de bloc et entre en vigueur, les anciennes versions qui ne l’ont pas sont déjà obsolètes. Lorsque nous approchons du numéro de bloc limite, je peux envoyer une alerte aux anciennes versions pour qu’elles sachent qu’elles doivent effectuer une mise à jour.&nbsp;» – Satoshi Nakamoto, <em>Re: [PATCH] increase block size limit</em>, 04/10/2010 19:48:40 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=1347.msg15366#msg15366" class="uri">https://bitcointalk.org/index.php?topic=1347.msg15366#msg15366</a>.</p></div></div><p>En dehors de BTC, les mises à niveaux par hard fork sont nombreuses, notamment en raison d’une économie moins grande et / ou plus centralisée. On peut citer les cas de Bitcoin Cash, de Monero, d’Ethereum Classic et d’Ethereum, où des mises à niveau de ce type sont réalisées régulièrement.</p>
<p>Le hard fork contentieux est un hard fork visant délibérément à créer une nouvelle chaîne. Il est issu d’une dissension dans la communauté, qui est si forte qu’elle pousse à la sécession. Il est généralement bilatéral.</p>
<p>Le premier exemple de hard fork contentieux majeur est celui qui a eu lieu sur Ethereum en juillet 2016, dans le contexte du piratage de TheDAO. Ce hard fork consistait à reprendre les fonds du pirate par un «&nbsp;changement d’état irrégulier&nbsp;». Celui-ci était rendu bilatéral par la règle imposant aux 10 premiers blocs d’inclure la chaîne de caractères dao-hard-fork. Puisque la majorité économique se trouvait du côté de l’annulation, la chaîne altérée a gardé le nom d’Ethereum et le sigle boursier ETH, tandis que l’autre chaîne a pris le nom d’Ethereum Classic et le sigle boursier ETC.</p>
<p>Le second exemple de hard fork contentieux est celui qui a mené à la création de Bitcoin Cash en août 2017 suite au débat sur la scalabilité et à la guerre des blocs. Ce hard fork n’intégrait pas SegWit, augmentait la taille limite des blocs à 8&nbsp;Mo et améliorait l’algorithme de signature. Il était rendu bilatéral par une règle qui imposait au bloc suivant l’activation d’avoir une taille strictement supérieure à 1&nbsp;Mo. Il offrait aussi <em>de facto</em> une protection contre la rediffusion des transactions. Ce changement ayant dû se faire sans l’accord de la majorité économique, la chaîne qui ne modifiait pas les règles a pu conserver le nom de Bitcoin et le sigle boursier BTC, tandis que la nouvelle chaîne a dû adopter un nouveau nom, Bitcoin Cash, et un nouveau sigle, BCH.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/hard-forks-eth-etc-bch-btc.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Exemples de hard forks bilatéraux&nbsp;: ETH / ETC et BCH / BTC."><img src="img/hard-forks-eth-etc-bch-btc.png" class="img-fluid figure-img" alt="Exemples de hard forks bilatéraux&nbsp;: ETH / ETC et BCH / BTC."></a></p>
<figcaption>Exemples de hard forks bilatéraux&nbsp;: ETH / ETC et BCH / BTC.</figcaption>
</figure>
</div>
<p>Notez qu’un tel hard fork peut être amené à modifier l’algorithme d’ajustement de la difficulté. En effet, si la puissance de calcul est trop faible pour le soutenir, il est possible que l’ajustement n’arrive pas à terme. C’est pour cette raison que Bitcoin Cash a dû implémenter un <em>Emergency Difficulty Adjustment</em> (EDA) qui a permis de procéder à l’adaptation sur une période plus courte. Ethereum Classic n’a cependant pas dû le faire, car l’ajustement sur Ethereum avait déjà lieu à tous les blocs.</p>
</section>
<section id="les-soft-forks" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="les-soft-forks">Les soft forks</h2>
<p>Passons maintenant au soft fork, qui est un procédé de mise à niveau souvent mal compris. Le soft fork est une restriction des règles de consensus. Il consiste ainsi par essence à rendre l’ensemble des blocs et des transactions valides plus petit, en ajoutant une règle ou en modifiant une règle existante de façon plus restrictive. L’exemple typique de ce genre de fork est la diminution de la taille limite des blocs. L’ajout de la limite explicite des 1&nbsp;Mo en octobre 2010 était de ce fait un soft fork.</p>
<p>Le soft fork peut être appliqué en conservant une seule et même chaîne. S’il est imposé par la majorité de la puissance de calcul du réseau, il n’y a aucun risque de scission. En effet, l’ensemble des blocs créés par les mineurs qui appliquent les nouvelles règles est entièrement compatible avec les anciennes règles, de sorte que la branche appliquant les nouvelles règles sera considérée comme la branche correcte par tous les nœuds si elle est majoritaire. Si l’application du soft fork est en revanche minoritaire, alors ce dernier résulte en deux chaînes persistantes distinctes. Les deux cas de figure sont illustrés sur la figure&nbsp;<a href="#fig:soft-fork" data-reference-type="ref" data-reference="fig:soft-fork">10.4</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/soft-fork-induced-forks.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Schéma d’un soft fork&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, seule la première survit&nbsp;; dans le cas contraire, les deux chaînes persistent."><img src="img/soft-fork-induced-forks.png" class="img-fluid figure-img" alt="Schéma d’un soft fork&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, seule la première survit&nbsp;; dans le cas contraire, les deux chaînes persistent."></a></p>
<figcaption>Schéma d’un soft fork&nbsp;: si la chaîne suivant la nouvelle règle est plus longue que celle suivant l’ancienne, seule la première survit&nbsp;; dans le cas contraire, les deux chaînes persistent.</figcaption>
</figure>
</div>
<p>Le concept de soft fork est postérieur à celui de hard fork. Il a été formellement découvert par Gavin Andresen en octobre 2011 qui, suite à son étude de la proposition d’ajout du code opération <code>OP_EVAL</code> par Nicolas van Saberhagen<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>, s’est aperçu que la mise à niveau pouvait se faire grâce au code opération <code>OP_NOP1</code> sans nécessairement provoquer de scission<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn19"><p><sup>19</sup>&nbsp;Nicolas van Saberhagen (ByteCoin), <em>OP_EVAL proposal</em>, 02/10/2011 00:49:19 UTC&nbsp;: <a href="https://bitcointalk.org/index.php?topic=46538.msg553689#msg553689" class="uri">https://bitcointalk.org/index.php?topic=46538.msg553689#msg553689</a>.</p></div><div id="fn20"><p><sup>20</sup>&nbsp;«&nbsp;Je lis probablement mal le code, mais je pense que OP_EVAL ne provoquerait pas de scission de la chaîne de blocs&nbsp;!&nbsp;» s’est exprimé Gavin Andresen sur IRC. – #bitcoin-dev IRC logs, 2 octobre 2010, archive&nbsp;: <a href="https://web.archive.org/web/20131201200245/http://bitcoinstats.com/irc/bitcoin-dev/logs/2011/10/02" class="uri">https://web.archive.org/web/20131201200245/http://bitcoinstats.com/irc/bitcoin-dev/logs/2011/10/02</a>.</p></div><div id="fn21"><p><sup>21</sup>&nbsp;Satoshi Nakamoto, <em>reverted makefile.unix wx-config – version 0.3.6 (git commit)</em>, 29/07/2010 18:27:12 UTC&nbsp;: <a href="https://sourceforge.net/p/bitcoin/code/119/" class="uri">https://sourceforge.net/p/bitcoin/code/119/</a>.</p></div></div><p>Les codes opération <code>OP_NOP</code> sont des instructions du langage de script de Bitcoin qui ont été ajoutés dans le code par Satoshi en juillet 2010 avec pour seul commentaire «&nbsp;expansion<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>&nbsp;». Le changement a été rendu effectif avec la version 0.3.6 du logiciel qui corrigeait également le 1 RETURN bug, publiée le 29 juillet. Leur rôle est initialement muet&nbsp;: s’ils sont présents dans un script, ils ne font rien mais ils n’invalident pas la transaction non plus. La conséquence directe est qu’on peut modifier le comportement de ces codes opération sans rendre les scripts incompatibles avec les anciennes règles de consensus. L’ajout de cette caractéristique indique donc que Satoshi avait saisi le mécanisme du soft fork.</p>
<p>Le soft fork possède un caractère «&nbsp;rétrocompatible&nbsp;» – ou postcompatible à proprement parler, car la compatibilité est ascendante et non descendante – dans le sens où les anciennes versions du logiciel peuvent continuer d’interagir avec le système. En effet, les nœuds non miniers suivant les anciennes règles continuent de voir les blocs produits comme valides. Cette caractéristique est un avantage majeur par rapport au hard fork.</p>
<p>Mais cette compatibilité ascendante ne veut pas dire qu’un soft fork est «&nbsp;doux&nbsp;». Il possède un côté pernicieux dans le sens où il rend la modification difficile à appréhender. Le soft fork présente ainsi plusieurs inconvénients.</p>
<p>D’abord, il n’est pas optionnel. S’il est appliqué par la majorité de la puissance de calcul, un soft fork s’apparente en effet à une attaque de censure pour les utilisateurs qui suivent les anciennes règles. Le soft fork possède donc un caractère coercitif que le hard fork n’a pas.</p>
<p>Puis, le soft fork est difficilement réversible. Les fonctionnalités ajoutées ne peuvent pas être désactivées simplement&nbsp;: une fois adopté, il n’y a pas de retour en arrière facile. Les développeurs de Bitcoin SV ont ainsi désactivé P2SH en février 2020 exposant les utilisateurs les moins attentifs à des vols.</p>
<p>Ensuite, le soft fork n’est pas limité quant à ce qu’il peut faire. Il peut augmenter la limite effective de taille des blocs (via un bloc auxiliaire aussi appelé bloc d’extension ou soft fork généralisé). Ce bloc d’extension peut également inclure des fonctionnalités supplémentaires (comme MimbleWimble dans Litecoin). Il peut même modifier la politique monétaire du protocole en redéfinissant l’unité de base<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;La façon dont un soft fork peut introduire de l’inflation dans Bitcoin a été exposée par le développeur Peter Todd en 2016. – Peter Todd, <em>Forced Soft Forks</em>, 18 janvier 2016&nbsp;: <a href="https://petertodd.org/2016/forced-soft-forks" class="uri">https://petertodd.org/2016/forced-soft-forks</a>.</p></div></div><p>Enfin, le soft fork, s’il est profond, crée une complexité supplémentaire, liée aux contraintes de son application. En effet, il ajoute de nouvelles exceptions aux règles de consensus, ce qui génère de la dette technique pour les développeurs.</p>
<p>L’archétype du soft fork profond et complexe a été la mise à niveau SegWit, ou <em>Segregated Witness</em>, qui consistait à déplacer les données de signature des transactions (appelées témoin ou <em>witness</em>) vers une structure de données séparée (<em>segregated</em>) afin de supprimer la malléabilité des transactions. Cette mise à niveau, qui a eu lieu le 24 août 2017, devait être initialement un hard fork, avant que le développeur Luke-Jr ne décrive en 2015 comment en faire un soft fork. La rétrocompatibilité était assurée par la liaison du témoin au bloc via un arbre de Merkle dont la racine était placée dans la transaction de récompense et par l’utilisation de sorties transactionnelles dépensables par n’importe qui (<em>anyone-can-spend</em>). Outre la correction du problème de malléabilité, elle a instauré un système de versionnage (qui a permis l’intégration de Schnorr-Taproot par la suite) et a modérément augmenté la capacité transactionnelle du réseau, de sorte que la taille effective des blocs pouvait dépasser 1&nbsp;Mo, jusqu’à 4&nbsp;Mo en théorie. Elle a également ajouté quatre nouveaux types d’adresse au protocole.</p>
<p>De plus, le soft fork requiert la majorité de la puissance de calcul du réseau pour préserver son intérêt. S’il n’est pas suivi à moyen terme par 51&nbsp;% de la puissance de calcul, alors son application provoque une scission. C’est ce qui explique pourquoi l’activation par les mineurs est généralement préférée à l’activation par les utilisateurs, même si le pouvoir de décision revient à ces derniers comme on le verra dans le chapitre&nbsp;<a href="la-determination-du-protocole.html" data-reference-type="ref" data-reference="ch:determination">11</a>.</p>
<p>D’une part, le soft fork activé par les utilisateurs (en anglais <em>user activated soft fork</em> ou UASF) consiste à implémenter le soft fork dans le code source du logiciel de sorte à ce qu’il rentre en application à une hauteur de bloc ou à un horodatage donné. Cette méthode s’appuie sur la confiance que l’économie appliquant la mise à niveau sera largement majoritaire et que l’activité minière suivra à moyen terme en raison d’une récompense de bloc plus élevée.</p>
<p>D’autre part, le soft fork activé par les mineurs (en anglais <em>miner activated soft fork</em> ou MASF) consiste à faire dépendre l’activation du signalement des mineurs au sein des blocs validés. Il est activé lorsqu’un certain seuil de signalement (95&nbsp;% par exemple) est dépassé. Cette méthode, dont la procédure a été notamment décrite dans le BIP-9, permet de s’assurer autant que possible que les mineurs appliquent la mise à niveau et qu’il ne subsiste qu’une seule chaîne.</p>
<p>La même distinction existe dans l’activation des hard forks, mais celle-ci a peu de pertinence, la puissance de calcul ne pouvant pas empêcher la scission. Ainsi, le hard fork activé par les mineurs ou MAHF, longtemps soutenu par les partisans de l’augmentation de la taille limite des blocs, n’a pas d’intérêt particulier. Comme les hard forks, les soft forks peuvent être rangés en deux catégories plus ou moins distinctes&nbsp;: le soft fork de mise à niveau et le soft fork contentieux. Le soft fork est idéal pour mettre à niveau le protocole. Cela permet aux nœuds de ne pas se mettre à niveau tout de suite. Même s’il demande une certaine synchronisation, celle-ci n’est pas aussi contraignante que pour les hard forks.</p>
<p>Dans BTC, le soft fork est ainsi privilégié par les développeurs depuis sa découverte. De nombreuses mises à niveau en étaient, comme <em>Pay to Script Hash</em> (BIP-16), ou l’obligation de spécifier la hauteur du bloc dans la transaction de récompense (BIP-34), ou encore l’ajout d’un standard d’encodage des signatures (BIP-66). Les ajouts des codes opération OP_CHECKLOCKTIMEVERIFY et OP_CHECKSEQUENCEVERIFY permettant l’usage de verrous temporels dans le langage de script par l’utilisation respective des codes <code>OP_NOP2</code> et <code>OP_NOP3</code> ont également été des soft forks. Enfin, plus récemment, l’adoption de Schnorr-Taproot (ou Taproot pour faire court) a été une mise à niveau par soft fork.</p>
<p>Litecoin fait aussi usage de ce type de transition. Le protocole a notamment intégré SegWit en mai 2017, ainsi que Schnorr-Taproot et MimbleWimble (MWEB) en mai 2022.</p>
<p>Le soft fork contentieux a pour objectif de contraindre la minorité de la communauté à suivre la majorité. S’il réussit, il n’y a qu’une seule chaîne, les opposants ayant le choix d’accepter les règles ou de procéder eux-mêmes à un hard fork. S’il échoue, il en résulte deux chaînes concurrentes.</p>
<p>SegWit est l’exemple typique d’un soft fork contentieux réussi. Il n’était pas approuvé par l’ensemble des acteurs importants (les partisans des gros blocs d’une part, les puristes du protocole comme Mircea Popescu d’autre part<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>, s’y opposaient), mais il a recueilli un soutien majoritaire de sorte qu’il a pu perdurer et que les <em>big blockers</em> mécontents ont dû migrer vers Bitcoin Cash.</p>
<div class="no-row-height column-margin column-container"><div id="fn23"><p><sup>23</sup>&nbsp;Mircea Popescu, <em>There’s a one Bitcoin reward for the death of Pieter Wuille. Details below.</em>, 10 décembre 2015&nbsp;: <a href="http://trilema.com/2015/theres-a-one-bitcoin-reward-for-the-death-of-pieter-wuille-details-below/" class="uri">http://trilema.com/2015/theres-a-one-bitcoin-reward-for-the-death-of-pieter-wuille-details-below/</a>.</p></div><div id="fn24"><p><sup>24</sup>&nbsp;Amaury Séchet, <em>Bitcoin ABC’s plan for the November 2020 upgrade</em>, 6 août 2020&nbsp;: <a href="https://amaurysechet.medium.com/bitcoin-abcs-plan-for-the-november-2020-upgrade-65fb84c4348f" class="uri">https://amaurysechet.medium.com/bitcoin-abcs-plan-for-the-november-2020-upgrade-65fb84c4348f</a>.</p></div></div><p>Un exemple de soft fork contentieux ayant échoué est la tentative de l’équipe de Bitcoin ABC d’imposer une redirection de 8&nbsp;% de la subvention de minage de Bitcoin Cash à son propre profit le 15 novembre 2020<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>. Cette tentative, qui était un soft fork en raison de son caractère restrictif, a provoqué la scission entre une branche majoritaire sans redirection (BCH) et une branche minoritaire avec, qui a été par la suite renommée en «&nbsp;eCash&nbsp;» (XEC).</p>
<p>Ainsi, le soft fork, qu’il soit approuvé à l’unanimité ou bien seulement par une majorité, est une méthode supérieure au hard fork. Bien qu’il soit parfois plus complexe, il permet de ne pas requérir une synchronisation de l’économie entière, cette dernière pouvant s’y adapter progressivement, ce qui est un bienfait non négligeable dans le cas d’un système ouvert utilisé par une grande diversité de personnes comme Bitcoin. Le signalement supermajoritaire des mineurs permet de minimiser le risque de scission et de conserver l’effet de réseau au maximum.</p>
<p>Mais cet avantage majeur se fait au prix d’un sacrifice&nbsp;: celui de la clarté du consentement. Dans le cas du hard fork, le consentement est clair&nbsp;: les personnes qui souhaitent la modification se retrouvent sur la chaîne qu’elles ont choisie. Dans le cas du soft fork, le consentement est plus ambigu&nbsp;: le fait d’opérer sur la chaîne n’indique pas nécessairement une acceptation active du changement, mais une résignation passive et un refus de réaliser un hard fork minoritaire. Comme l’écrivait brillamment Vitalik Buterin en mars 2017&nbsp;:</p>
<p>«&nbsp;Les soft forks favorisent clairement la coercition par rapport à la sécession d’un point de vue systémique, alors que les hard forks ont le penchant inverse<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>.&nbsp;»</p>
<div class="no-row-height column-margin column-container"><div id="fn25"><p><sup>25</sup>&nbsp;Vitalik Buterin, <em>Hard Forks, Soft Forks, Defaults and Coercion</em>, 14 mars 2017&nbsp;: <a href="https://vitalik.ca/general/2017/03/14/forks_and_markets.html" class="uri">https://vitalik.ca/general/2017/03/14/forks_and_markets.html</a>.</p></div></div><p>Ainsi, même s’ils sont supérieurs de manière générale, les soft forks ne sont pas adaptés à toutes les situations.</p>
</section>
<section id="lévolution-plurielle-de-bitcoin" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lévolution-plurielle-de-bitcoin">L’évolution plurielle de Bitcoin</h2>
<p>Le fonctionnement ouvert et libre de l’évolution de Bitcoin fait que le protocole peut être modifié à volonté. Bitcoin évolue de manière organique, lentement mais sûrement&nbsp;: il n’est pas un système figé, dont les règles seraient dictées par une autorité centrale. Et, par là, il s’améliore avec le temps.</p>
<p>Cette ouverture implique aussi que la mise en œuvre de Bitcoin est nécessairement plurielle. Bitcoin n’est pas un système unique, mais un modèle ouvert qui est appliqué de façon plus ou moins fidèle par plusieurs protocoles. L’ensemble des mises en œuvre de Bitcoin constitue un arbre dont les branches proviennent d’un même tronc et des mêmes racines.</p>
<p>Toutefois, toutes les branches ne sont pas équivalentes&nbsp;: toutes les mises en œuvre n’ont pas la même importance. L’une d’entre elles (BTC) est aujourd’hui supermajoritaire, de sorte que nous l’appelons naturellement Bitcoin, et sa modification est (heureusement) difficile. Dans le prochain chapitre, nous examinerons le mécanisme sous-jacent qui fait que Bitcoin est ce qu’il est aujourd’hui et comment l’évolution du protocole est gouvernée.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="img/bitcoin-forks-tree.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Variations conceptuelles, modifications logicielles et forks de consensus de Bitcoin."><img src="img/bitcoin-forks-tree.png" class="img-fluid figure-img" alt="Variations conceptuelles, modifications logicielles et forks de consensus de Bitcoin."></a></p>
<figcaption>Variations conceptuelles, modifications logicielles et forks de consensus de Bitcoin.</figcaption>
</figure>
</div>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/la-resistance-a-la-censure.html" class="pagination-link" aria-label="La résistance à la censure">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">La résistance à la censure</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/la-determination-du-protocole.html" class="pagination-link" aria-label="La détermination du protocole">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">La détermination du protocole</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © 2024 Konsensus Network
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../index.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../produit.html">
<p>Acheter</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/konsensusn">
      <i class="bi bi-twitter" role="img" aria-label="Twitter">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/konsensusnetwork">
      <i class="bi bi-github" role="img" aria-label="Github">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/konsensusnetwork">
      <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/konsensusnetwork">
      <i class="bi bi-youtube" role="img" aria-label="YouTube">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","openEffect":"zoom","loop":false,"descPosition":"bottom","closeEffect":"zoom"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>