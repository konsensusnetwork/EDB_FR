<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>10&nbsp; The Evolution of Currency – L'Élégance de Bitcoin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/la-determination-du-protocole.html" rel="next">
<link href="../chapters/la-resistance-a-la-censure.html" rel="prev">
<link href="..//figures/freestarfish.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="10&nbsp; The Evolution of Currency – L’Élégance de Bitcoin">
<meta property="og:description" content="">
<meta property="og:image" content="cover.png">
<meta property="og:site_name" content="L'Élégance de Bitcoin">
<meta name="twitter:title" content="10&nbsp; The Evolution of Currency – L’Élégance de Bitcoin">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="cover.png">
<meta name="twitter:site" content="@konsensusn">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">L’Élégance de Bitcoin</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> <i class="bi bi-book" role="img" aria-label="Book">
</i> 
<span class="menu-text">Lire en ligne</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://bitcoinbook.shop/products/lelegance-de-bitcoin"> <i class="bi bi-shop" role="img" aria-label="Shop">
</i> 
<span class="menu-text">Acheter ce livre!</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/le-changement-de-la-monnaie.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Evolution of Currency</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="sidebar-tools-main">
    <div id="quarto-search" class="quarto-navigation-tool px-1" title="Search"></div>
</div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">À propos de ce livre</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/preface-de-jacques-favier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface by Jacques Favier</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/remerciements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgments</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/avant-propos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-debuts-de-bitcoin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">The Beginnings of Bitcoin</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/une-croissance-conflictuelle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">A Conflict-Ridden Growth</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/des-racines-monetaires.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">The Monetary Roots</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-necessite-de-decentralisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Necessity of Decentralization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/un-mouvement-technologique.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Un mouvement technologique</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-cybermonnaie-avant-nakamoto.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Cryptocurrency Before Nakamoto</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-valeur-de-l-information.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">The Value of Information</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-consensus-par-le-minage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Consensus Through Mining</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-resistance-a-la-censure.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Resistance to Censorship</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-changement-de-la-monnaie.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Evolution of Currency</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/la-determination-du-protocole.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Determining the Protocol</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-rouages-de-la-machine.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">The Inner Workings of the Machine</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/les-contrats-autonomes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Autonomous Contracts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/le-passage-a-l-echelle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Scaling Up</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/l-avenir-de-bitcoin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">The Future of Bitcoin</span></span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-protocol" id="toc-the-protocol" class="nav-link active" data-scroll-target="#the-protocol">The Protocol</a></li>
  <li><a href="#software-implementations" id="toc-software-implementations" class="nav-link" data-scroll-target="#software-implementations">Software Implementations</a></li>
  <li><a href="#bitcoin-improvement-proposals" id="toc-bitcoin-improvement-proposals" class="nav-link" data-scroll-target="#bitcoin-improvement-proposals">Bitcoin Improvement Proposals</a></li>
  <li><a href="#verifying-consensus-rules" id="toc-verifying-consensus-rules" class="nav-link" data-scroll-target="#verifying-consensus-rules">Verifying Consensus Rules</a></li>
  <li><a href="#hard-forks" id="toc-hard-forks" class="nav-link" data-scroll-target="#hard-forks">Hard Forks</a></li>
  <li><a href="#soft-forks" id="toc-soft-forks" class="nav-link" data-scroll-target="#soft-forks">Soft Forks</a></li>
  <li><a href="#bitcoins-plural-evolution" id="toc-bitcoins-plural-evolution" class="nav-link" data-scroll-target="#bitcoins-plural-evolution">Bitcoin’s Plural Evolution</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="ch:change" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Evolution of Currency</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>[] {#enotezch:10 label=“enotezch:10”}</p>
<p><span class="lettrine">O</span><span class="smallcaps">ne</span> currency is an agreement on a mutually acceptable means of trade. This agreement can pertain to physical properties—in which case the monetary medium is a commodity—or to digital properties, where the monetary medium is a computational protocol. Bitcoin belongs to this latter category.</p>
<p>Due to its open and free nature, Bitcoin’s code can be copied, modified, and reused at will. Consequently, the protocol (and the currency it defines) can also be changed by applying different code to the network. Bitcoin is thus not a static system managed by a central authority but an open structure that undergoes organic evolution over time.</p>
<section id="the-protocol" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="the-protocol">The Protocol</h2>
<p>At its core, Bitcoin is a computer communication protocol—a set of rules enabling different parts of a network to exchange information. This protocol allows nodes in the peer-to-peer network to share transactions and blocks and to agree on the correct ledger of ownership. The result is a monetary system.</p>
<p>Bitcoin closely resembles existing protocols, to varying degrees. For example, it is akin to other protocols built on the Internet, such as HTTP (<em>HyperText Transfer Protocol</em>), used for displaying web pages; SMTP (<em>Simple Mail Transfer Protocol</em>), used for email; or BitTorrent, which facilitates peer-to-peer file sharing. It also parallels the protocols underpinning the Internet itself, known as the TCP/IP suite, named after its first two components: IP (<em>Internet Protocol</em>), which handles communication at the network layer, and TCP (<em>Transmission Control Protocol</em>), which manages transmission at the transport layer, overlaying the network layer.</p>
<p>More distantly, programming languages can be considered protocols. These languages allow code (specific text encoded in UTF-8) to be written and then transformed into executable files by a compiler (as with C, C++, or Java) or directly executed by an interpreter (as with Python or JavaScript). Similarly, human languages like French or English are communication protocols with less formal and well-defined rules but enable people to exchange information.</p>
<p>Finally, currencies can be viewed as types of protocols, serving as common means to communicate value and formalize economic exchange. A currency is particularly defined by the medium accepted in commerce: for a commodity like gold or silver, the medium is a chemical element; for fiat money, it is a certificate issued by an authority.</p>
<p>In Bitcoin’s case, the protocol comprises all the rules that enable the network to communicate and coordinate. This protocol is divided into two distinct parts: the transmission protocol, consisting of network rules, and the protocol governing the transmitted content, consisting of consensus rules.</p>
<p>Network rules govern how nodes communicate over the Internet. These rules concern the underlying transport protocol (TCP, Tor, UDP for FIBRE), the network port (8333 for the main BTC network), peer discovery procedures, message syntax for data transmission, and so on. These rules can vary between nodes without formally breaking consensus; a node accepting both rule sets can act as a bridge. Similarly, nodes are free to restrict (temporarily or permanently) their connections with other nodes, particularly to prevent spam.</p>
<p>Consensus rules govern the construction and organization of blocks and transactions. They regulate the validity of the ledger on which network members agree, hence their name. These rules are critical: a node transmitting an invalid transaction or block to other nodes will have its transaction or block rejected by the rest of the network.</p>
<p>The consensus rules are numerous. Some are widely known and explicit. Here are a few examples:</p>
<ul>
<li><p>The input amount of a transaction must be greater than (or equal to) the output amount, with the difference representing the fees collected by the miner.</p></li>
<li><p>Each input must contain an unlocking script (containing one or more signatures) that corresponds to the locking script (the sending address) of the spent output.</p></li>
<li><p>A transaction output can be spent only once, due to the prohibition of double spending.</p></li>
<li><p>Each block must include a proof of work, produced by repeatedly hashing the block header using the SHA-256 function, exceeding the network’s difficulty level.</p></li>
<li><p>The subsidy in each block must be below a limit, which is halved every 210,000 blocks (approximately every 4 years).</p></li>
<li><p>Mining difficulty is adjusted every 2,016 blocks (approximately every 2 weeks) to ensure an average time of 10 minutes between blocks.</p></li>
<li><p>The block weight is limited to 4 million weight units (as defined by SegWit), which restricts the system’s transactional capacity.</p></li>
</ul>
<p>The consensus rules are too numerous to list exhaustively. When they are not explicitly stated, these rules are implicitly defined in the reference software implementation, which is Bitcoin Core in the case of BTC.</p>
</section>
<section id="software-implementations" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="software-implementations">Software Implementations</h2>
<p>Software implementations are the computer programs that execute the protocol. In the case of full node implementations, all consensus rules are enforced. Implementations can also be partial, in which case they do not enforce all consensus rules—for example, lightweight wallets that perform simplified verification of their transactions.</p>
<p>In BTC, multiple implementations exist, including Bitcoin Core, Libbitcoin, btcd, and Bitcoin Knots. The most well-known is Bitcoin Core, which is both the historical implementation created by Satoshi Nakamoto (the “Satoshi client”) and taken over by Gavin Andresen in 2010, the main implementation used by over 99% of nodes as of November 2023, and the reference implementation that defines implicit consensus rules.</p>
<p>Other protocols have different implementations. Bitcoin Cash, for instance, has multiple implementations, with the two main ones being Bitcoin Cash Node (the reference implementation derived from Bitcoin ABC, itself derived from Bitcoin Core) and Bitcoin Unlimited. Ethereum also relies on a diversity of implementations that manage transaction transmission and verification (Geth, Nethermind, etc.) or block verification (Prysm, Lighthouse, etc.).</p>
<p>An implementation is generally free software, meaning its code is openly published under a license that allows use, modification, and reproduction. This technical and legal characteristic is <em>essential</em> to Bitcoin, as it not only allows verification of the software’s operation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> but also enables users to take control of the code if developers move in an undesired direction.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;“Open source code means that anyone can independently review the code. If it were closed source, nobody could verify the security. I think it’s essential for a program of this nature to be open source.” — Satoshi Nakamoto, <em>Re: Questions about Bitcoin</em>, 12/10/2009 20:49:02 UTC: <a href="https://bitcointalk.org/index.php?topic=13.msg46#msg46" class="uri">https://bitcointalk.org/index.php?topic=13.msg46#msg46</a>.</p></div></div><p>Copying and modifying software is known as a <em>fork</em>. It involves creating new software from the source code of existing software, stemming from a different vision for the software’s development. Linux distributions are formed in this way from earlier distributions. Other examples include OpenOffice.org, which gave rise to LibreOffice and Apache OpenOffice.</p>
<p>Bitcoin Core is directly descended from the first implementation coded by Satoshi Nakamoto and publicly shared on January 8, 2009. Initially called simply “Bitcoin,” the software was renamed bitcoind/Bitcoin-Qt in 2011 and then rebranded as Bitcoin Core on March 19, 2014.</p>
<p>Bitcoin Core is software written in C++. Initially hosted on SourceForge, the code is now available on GitHub<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. It is released under the permissive MIT license, allowing anyone to copy and modify it at will. Specifically, the MIT license permits reuse of the code as part of or as a basis for software under a proprietary license. Satoshi chose this license over the GPL due to its compatibility with other licenses<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;<em>Bitcoin Core integration/staging tree</em>: <a href="https://github.com/bitcoin/bitcoin" class="uri">https://github.com/bitcoin/bitcoin</a>.</p></div><div id="fn3"><p><sup>3</sup>&nbsp;Satoshi Nakamoto, <em>Re: Switch to GPL</em>, 09/12/2010 19:24:53 UTC: <a href="https://bitcointalk.org/index.php?topic=989.msg12494#msg12494" class="uri">https://bitcointalk.org/index.php?topic=989.msg12494#msg12494</a>.</p></div></div><p>The development of Bitcoin Core is open and meritocratic. The GitHub repository is open to all, and anyone can contribute to the maintenance and improvement of the software by submitting a pull request. Frequent contributors are known as “core developers.” To facilitate development, contributors communicate through various means, with the two main channels being the bitcoin-core-dev IRC channel, where most discussions take place, and the bitcoin-dev mailing list.</p>
<p>However, Bitcoin Core does have a certain hierarchy. The repository is managed by maintainers responsible for merging code modifications proposed by contributors. Inclusion in the code depends on various criteria assessed by these maintainers, such as the demonstrable utility of the change, adherence to the project’s guidelines, peer review, or the contributor’s reputation<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;“Maintainers will consider a patch if it aligns with the project’s overall principles, meets the minimum inclusion standards, and assess the general consensus of contributors.” — <em>Contributing to Bitcoin Core</em>, May 26, 2023: <a href="https://github.com/bitcoin/bitcoin/blob/25.x/CONTRIBUTING.md" class="uri">https://github.com/bitcoin/bitcoin/blob/25.x/CONTRIBUTING.md</a>.</p></div><div id="fn5"><p><sup>5</sup>&nbsp;Wladimir J. van der Laan, <em>The widening gyre</em>, January 21, 2021, archived: <a href="https://web.archive.org/web/20210121201607/https://laanwj.github.io/2021/01/21/decentralize.html" class="uri">https://web.archive.org/web/20210121201607/https://laanwj.github.io/2021/01/21/decentralize.html</a>; Wladimir J. van der Laan, <em>Remove laanwj from trusted-keys (git commit)</em>, 02/07/2023 09:12 UTC: <a href="https://github.com/bitcoin/bitcoin/commit/aafa5e945cef7a4f65ddadcf548932dd4e27ada1" class="uri">https://github.com/bitcoin/bitcoin/commit/aafa5e945cef7a4f65ddadcf548932dd4e27ada1</a>.</p></div></div><p>Initially, the software was overseen by a lead maintainer who was responsible for appointing other maintainers, deciding the software’s release cycle, merging all modifications, and moderating debates. This role was first held by Satoshi Nakamoto, who managed the integration of contributions on the SourceForge repository. On February 23, 2011, Satoshi transferred responsibility to Gavin Andresen before disappearing for good. Gavin then led the project for over three years before passing the mantle to Wladimir J. van der Laan on April 7, 2014. On February 7, 2023, van der Laan stepped down after nine years of service. The lead maintainer position was subsequently abolished and replaced with collective responsibility among the maintainers<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>As of November 2023, there were five Bitcoin Core maintainers: Michael Ford, Hennadii Stepanov, Andrew Chow, Gloria Zhao, and Ryan Ofsky. They follow in the footsteps of notable former maintainers (excluding lead maintainers) such as Martti Malmi, Laszlo Hanyecz, Chris Moore, Pieter Wuille, Jeff Garzik, Nils Schneider, Gregory Maxwell, Jonas Schnelli, Samuel Dobson, and Marco Falke. Among active contributors who have never been maintainers are Matt Corallo, practicalswift, Luke-Jr, and John Newbery. The PGP fingerprints of the maintainers are publicly available in the repository.</p>
<p>This open approach gives the software greater security than most computer programs. Given the sums at stake, the reward for successfully exploiting a major vulnerability would be enormous, so one can assume that such a vulnerability has not been discovered. While vulnerabilities in the software may exist, they are very rare and subtle, typically discovered by well-intentioned developers—for example, developer Awemany responsibly disclosed an inflationary bug in the code in September 2018<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. Thus, the passage of time increases confidence in the software (and the system), in accordance with the Lindy effect<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Awemany, <em>600 Microseconds</em>, September 21, 2018: <a href="https://medium.com/@awemany/600-microseconds-b70f87b0b2a6" class="uri">https://medium.com/@awemany/600-microseconds-b70f87b0b2a6</a>.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;As Hal Finney noted in 2011: “Each day that passes without Bitcoin collapsing due to legal or technical problems brings new information to the market. This increases the chances of Bitcoin’s success and justifies a higher price.” — Hal Finney, <em>Re: Bitcoin and the Efficient Market Hypothesis</em>, 06/04/2011 23:36:04 UTC: <a href="https://bitcointalk.org/index.php?topic=11765.msg169026#msg169026" class="uri">https://bitcointalk.org/index.php?topic=11765.msg169026#msg169026</a>.</p></div></div></section>
<section id="bitcoin-improvement-proposals" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="bitcoin-improvement-proposals">Bitcoin Improvement Proposals</h2>
<p>Implementations can be updated by their developers, each following their own decision-making model. In Bitcoin Core, as mentioned, anyone can propose code changes, but the final decision rests with the developers. Similarly, internal changes related to wallets are managed by their respective developers.</p>
<p>However, there’s a way to propose changes that can apply to all implementations: Bitcoin Improvement Proposals (BIPs), which are documents describing possible protocol changes or providing general information to the community. The BIP system was formalized by Amir Taaki in 2011, based on Python Enhancement Proposals (PEPs) used to improve the Python programming language. Initially defined by BIP-1, the procedure is now described by BIP-2, written by Luke-Jr.&nbsp;It is hosted on a GitHub repository managed by Bitcoin Core.</p>
<p>BIPs can be categorized into three types: Standard Track BIPs, which concern changes affecting most or all Bitcoin implementations; Informational BIPs, which describe design issues or offer general guidelines or information to the Bitcoin community but do not propose new features; and Process BIPs, which describe or propose a process change. Standard Track BIPs are the most common and can pertain to various aspects: consensus rules, transmission protocol (<em>Peer Services</em>), software interfaces (<em>API/RPC</em>), or conventions used in applications<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;Eric Lombrozo, <em>BIP-123: BIP Classification</em>, August 26, 2015: <a href="https://github.com/bitcoin/bips/blob/master/bip-0123.mediawiki" class="uri">https://github.com/bitcoin/bips/blob/master/bip-0123.mediawiki</a>.</p></div></div><p>Before adoption, a BIP must undergo several stages. First, one or more authors are assigned to draft an initial version that adheres to the specified format and takes into account the current state of the art. The BIP is then shared with the Bitcoin developer community, usually via the development mailing list (bitcoin-dev). Discussions occur on this mailing list. Next, the BIP is officially proposed to the system as a pull request on the GitHub repository, which must be approved by the editor designated by Bitcoin Core (Luke-Jr since 2016). Finally, it is assigned a number and included in the repository as a draft. It can later change status over time, depending on community adoption, with the goal of becoming final or active.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/bip-process-fr.png" class="img-fluid figure-img"></p>
<figcaption>Diagram of the BIP adoption procedure, inspired by BIP-1.</figcaption>
</figure>
</div>
<p>Note that these documents are used for BTC but also for other protocols. For example, BIPs describing wallet functionalities (BIP-32, BIP-39, BIP-44) are valid for the vast majority of cryptocurrencies. The SLIP-44 lists cryptocurrencies compatible with BIP-44. Other crypto-economic protocols sometimes have their own proposal systems. Ethereum uses EIPs (<em>Ethereum Improvement Proposals</em>), Bitcoin Cash has CHIPs (<em>Cash Improvement Proposals</em>), Litecoin uses LIPs, and so on.</p>
</section>
<section id="verifying-consensus-rules" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="verifying-consensus-rules">Verifying Consensus Rules</h2>
<p>Bitcoin is based on a publicly accessible network of computers on the Internet. This network follows a peer-to-peer model, where all network members, called nodes, have equal privileges. These nodes ensure that the consensus rules are respected. If a block is invalid (containing an invalid transaction, for example), it is rejected by nodes enforcing the rules.</p>
<p>In Bitcoin, nodes maintain a copy of the transaction ledger (the blockchain) and, in doing so, ensure the validity of transactions and blocks. They communicate with other network nodes and relay new transactions and blocks, originating from users and miners, respectively.</p>
<p>Consensus rule verification can be complete. In this case, the term “full nodes” emphasizes that they verify the entire chain. These nodes download the entire blockchain, check the consensus rules, and relay blocks and transactions. This is resource-intensive, both in terms of data storage (as of November 2023, the Bitcoin chain was approximately 530 GB, and the entire UTXO set over 8.5 GB) and bandwidth (the average size of blocks mined every 10 minutes was around 1.7 MB in November 2023).</p>
<p>Pruned nodes, which maintain the network state but not the entire chain, are full nodes because they have verified compliance with the rules over the entire chain. They simply cannot access the chain’s history before a certain date.</p>
<p>Verification can also be partial, in which case we speak of light clients (or “light nodes” colloquially). This is useful for people who have no interest in running a full node—for example, in hashing software (implementing Stratum) and in lightweight wallets. They use a method conceptualized in the Bitcoin white paper in 2008: Simplified Payment Verification<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;Satoshi Nakamoto described Simplified Payment Verification as follows: “It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he is convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it’s timestamped in. He can’t check the transaction himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.” — Satoshi Nakamoto, <em>Bitcoin: A Peer-to-Peer Electronic Cash System</em>, October 31, 2008.</p></div></div><p>Simplified Payment Verification (SPV) is a clever method that allows novice and occasional users to interact easily with the protocol without running a full node or blindly trusting a custodian. It significantly reduces the load on lightweight wallets.</p>
<p>SPV relies on how transactions are chained and structured, as we saw in Chapter <a href="le-consensus-par-le-minage.html" data-reference-type="ref" data-reference="ch:confirmation">8</a>. First, the proof-of-work chain is not strictly a chain of blocks but a chain of headers. This means light clients only need to keep this chain of headers to determine the chain with the most accumulated work. Since each header is 80 bytes, the amount of data to store remains modest for modern devices: it increases by about 4 MB per year, totaling just over 62 MB in November 2023.</p>
<p>Second, transactions are arranged in a Merkle tree, allowing light clients to request only the branch information they’re interested in to verify the confirmation of one of their transactions. The number of hashes to obtain and compute depends on the binary logarithm (<span class="math inline">\(\log_{2}\)</span>) of the number of transactions in the block. For a block with 3,000 transactions (a high average on BTC), the load corresponds to requesting 12 hashes of 32 bytes and performing 12 hash computations for verification.</p>
<p>This simplified verification lightens the load on wallets but has major drawbacks. First, it lacks reliability: nodes cannot lie by inventing a transaction but can omit necessary information. This shortcoming can be partially mitigated by increasing the diversity of network connections. However, even then, verification remains vulnerable if the chain is attacked by an entity controlling the majority of computing power<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;This case was described by Satoshi Nakamoto in the white paper: “As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker’s fabricated transactions as long as the attacker can overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user’s software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.” — Satoshi Nakamoto, <em>Bitcoin: A Peer-to-Peer Electronic Cash System</em>, October 31, 2008.</p></div><div id="fn11"><p><sup>11</sup>&nbsp;One initial way to address the privacy issue was to implement Bloom filters, as described in BIP-37, but this method was ineffective. See Arthur Gervais, Srdjan Capkun, Ghassan O. Karame, Damian Gruber, “<em>On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients</em>”, in <em>Proceedings of the 30th Annual Computer Security Applications Conference</em>, December 2014, pp.&nbsp;326–335: <a href="https://eprint.iacr.org/2014/763.pdf" class="uri">https://eprint.iacr.org/2014/763.pdf</a>. There’s also Neutrino, described in BIP-157 and BIP-158, which uses Golomb-Rice coding and requires more bandwidth.</p></div></div><p>Second, SPV lacks privacy because the client must reveal some of its transactional activity through requests to network nodes. One way to partially address this is to increase the amount of information requested to mask essential details, but this method is far from perfect<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p>
<p>Finally, SPV inherently provides partial verification. Not all consensus rules are checked, meaning full nodes could agree on a rule change that goes unnoticed by the light client. For example, SPV clients do not verify constraints on block size, so the network could modify this limit without their awareness. This explains the strategy of SegWit2X proponents in 2017, who planned to double the block size limit without replay protection so that SPV wallets would simply follow the longest chain.</p>
<p>Satoshi believed the system could persist with centralized verification by a few verifying nodes (including miners) and that other users would employ light clients. In his first response to James A. Donald in November 2008, he stated:</p>
<p>“Long before the network gets anywhere near as large as that, users can use simplified payment verification (section 8) to check for double-spending, which only requires having the chain of block headers or about 12KB per day. Only people trying to create new coins would need to run network nodes<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>.”</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;Satoshi Nakamoto, <em>Re: Bitcoin P2P e-cash paper</em>, 11/03/2008, 01:37:43 UTC: <a href="https://www.metzdowd.com/pipermail/cryptography/2008-November/014815.html" class="uri">https://www.metzdowd.com/pipermail/cryptography/2008-November/014815.html</a>.</p></div></div><p>In this, he was mistaken. Verifying consensus rules needs to be comprehensive for those rules to be enforced.</p>
<p>Thus, it is at the full node level that this verification occurs, a reality sometimes encapsulated by the adage “not your node, not your rules<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>.” Don’t trust, verify! Much like a language results from the choices made by its speakers, a computer protocol results from the rules enforced by full nodes. This verification plays a crucial role in determining the protocol.</p>
<div class="no-row-height column-margin column-container"><div id="fn13"><p><sup>13</sup>&nbsp;Understanding Bitcoin, <em>Not Your Node Not Your Rules! w/ Ketominer, Udi Wertheimer, Francis Pouliot &amp; Mir Liponi</em> (video), April 5, 2019: <a href="https://www.youtube.com/watch?v=jwaKVIEm-rI" class="uri">https://www.youtube.com/watch?v=jwaKVIEm-rI</a>.</p></div></div></section>
<section id="hard-forks" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="hard-forks">Hard Forks</h2>
<p>Since Bitcoin is open and free, the consensus rules can be modified at will by network nodes by changing the acceptance of blocks and transactions. These modifications can lead to network conflicts and potentially to a split into two separate networks, each managing its own chain and currency. This phenomenon is referred to as a <em>fork</em>.</p>
<p>Consensus rule changes are commonly categorized into two types: <em>hard forks</em>, which are brute and incompatible upgrades, and <em>soft forks</em>, which have a degree of backward compatibility. Let’s explore how these changes manifest, starting with hard forks before describing soft forks.</p>
<p>In Bitcoin, the term <em>fork</em> is polysemous, bearing four different meanings: software fork, consensus rule fork, common chain fork, and persistent chain fork. This polysemy can cause confusion, so different terms are preferred for each meaning.</p>
<p>First, <em>fork</em> is used in software development, particularly in free software that permits and encourages this practice. It refers to creating a program derived from the source code of an existing program and, by extension, the derivative program itself. In this sense, the reference implementation can undergo a fork, creating alternative software. This software may adhere to the consensus rules (like Bitcoin Knots) or deviate from them by creating a new protocol that shares the chain’s history (Bitcoin ABC, later Bitcoin Cash Node) or not (Litecoin).</p>
<p>Second, <em>fork</em> can denote the common branching of the blockchain, by analogy with software development. The blockchain is not a linear structure but a “tree-shaped structure<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>” that can have multiple branches of blocks, all compatible with the consensus rules accepted by the network, with the correct branch selected as the longest one (having the most accumulated work). This type of branching occurs regularly in Bitcoin quite normally and benignly when two miners simultaneously find different blocks, and it’s resolved when a new block is found.</p>
<div class="no-row-height column-margin column-container"><div id="fn14"><p><sup>14</sup>&nbsp;Satoshi Nakamoto, source code of Bitcoin version 0.1: <a href="https://github.com/trottier/original-bitcoin/blob/4184ab26345d19e87045ce7d9291e60e7d36e096/src/main.h#L1001-L1008" class="uri">https://github.com/trottier/original-bitcoin/blob/4184ab26345d19e87045ce7d9291e60e7d36e096/src/main.h#L1001-L1008</a>.</p></div></div><p>Third, <em>fork</em> can refer to a blockchain split caused by incompatibility of consensus rules. This is called a hard fork or “divergent fork.” This split is usually permanent in the sense that the two resulting branches cannot reconcile through Nakamoto’s consensus mechanism unless a very specific condition is met: if the majority branch’s rules form a restrictive subset of the minority branch’s rules. Ultimately, the two resulting chains are destined to exist on separate networks.</p>
<p>Finally, <em>fork</em> can, by metonymy, denote a change in consensus rules, which can always cause a chain split and network separation. A restriction of consensus rules is called a soft fork, or “convergent fork,” due to its ability to result in a single branch. Any other modification of consensus rules, whether an extension or strictly incompatible change, is called a hard fork, referencing its propensity to create a chain split. These are the two modifications we’ll discuss here<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn15"><p><sup>15</sup>&nbsp;Note that the concepts are related. For example, a software fork (copy and modification) can implement a consensus rule fork (hard or soft fork) that ultimately creates a persistent chain fork (split).</p></div><div id="fn16"><p><sup>16</sup>&nbsp;David François (davout), <em>Re: Small protocol changes for flexibility</em>, 12/07/2010 15:08:02 UTC: <a href="https://bitcointalk.org/index.php?topic=894.msg27757#msg27757" class="uri">https://bitcointalk.org/index.php?topic=894.msg27757#msg27757</a>.</p></div></div><p>The hard fork is the older concept compared to the soft fork. It was previously termed an “incompatible change<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>.” A hard fork is a non-restrictive modification of the consensus rules. It causes a network conflict between nodes enforcing the old rules and those enforcing the new ones.</p>
<p>A hard fork can be extensive, meaning it broadens the consensus rules on blocks and transactions. Old nodes can thus produce valid blocks on the new chain but not vice versa. A typical example of such a hard fork is increasing the block size limit, accepting larger blocks—2 MB instead of 1 MB, or 8 MWU instead of 4 MWU. This extensive hard fork is illustrated in Figure <a href="#fig:expanding-hard-fork" data-reference-type="ref" data-reference="fig:expanding-hard-fork">10.1</a>.</p>
<div id="fig:expanding-hard-fork" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/expanding-hard-fork-induced-forks.png" class="img-fluid figure-img"></p>
<figcaption>Diagram of an extensive hard fork: If the chain following the new rule is longer than the one following the old rule, both chains persist; otherwise, only the second survives.</figcaption>
</figure>
</div>
<p>If the extensive hard fork is not supported by a majority of the network’s computing power, it may fail to create a persistent branch. For instance, blocks from the branch imposing a smaller size limit are entirely compatible with the new rules, so if it’s longer, it will be selected as the correct branch. To avoid this problematic situation, hard forks are generally bilateral.</p>
<p>A bilateral hard fork is a hard fork that creates a total incompatibility between the new rules and the old ones. This can involve adding a rule requiring the first block of the fork to include an incompatible change. In our block size limit increase example, this would mean requiring the first block to be strictly larger than the previous limit, as shown in Figure <a href="#fig:expanding-hard-fork-failure" data-reference-type="ref" data-reference="fig:expanding-hard-fork-failure">10.2</a>. This additional rule is called wipeout protection.</p>
<div id="fig:expanding-hard-fork-failure" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/bilateral-hard-fork-induced-fork.png" class="img-fluid figure-img"></p>
<figcaption>Diagram of a bilateral hard fork: The new rules are strictly incompatible with the old ones, so both chains persist.</figcaption>
</figure>
</div>
<p>Another example is changing the transaction signature algorithm, rendering all signed transactions and non-empty blocks strictly incompatible. This change can also provide replay protection if two competing chains persist.</p>
<p>Two scenarios can result from a hard fork: either the vast majority of the economy adopts the change, resulting in a single chain, or the economy fragments, and both chains persist. The first scenario is aimed for in a planned upgrade hard fork, which doesn’t intend to create two separate chains. The second arises from a contentious hard fork due to community division over the change. Accidental hard forks, caused by unintended modifications of implicit consensus rules, are excluded here<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;On March 11, 2013, the migration from version 0.7 to version 0.8 of the software implemented a shift from the Berkeley DB database system to LevelDB. However, it turned out that Berkeley DB had a default lock limit not present in LevelDB. Consequently, the migration constituted an accidental hard fork, causing a split from block 225,430 that lasted about 6 hours. The decision was ultimately made to revert to version 0.7, invalidating the 24-block branch mined on version 0.8’s side, and to proceed with the migration months later. — See Vitalik Buterin, “<em>Bitcoin Network Shaken by Blockchain Fork</em>”, <em>Bitcoin Magazine</em>, March 13, 2013: <a href="https://bitcoinmagazine.com/technical/bitcoin-network-shaken-by-blockchain-fork-1363144448" class="uri">https://bitcoinmagazine.com/technical/bitcoin-network-shaken-by-blockchain-fork-1363144448</a>; and Gavin Andresen, <em>BIP-50: March 2013 Chain Fork Post-Mortem</em>: <a href="https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki" class="uri">https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki</a>.</p></div></div><p>A planned upgrade hard fork is a hard fork that requires synchronization of almost the entire community. It usually results in a single chain, effectively upgrading the protocol, though it’s essentially economic usage shifting from one protocol to another. It can be extensive, though bilaterality is preferred for security reasons.</p>
<p>The first known planned upgrade hard fork was likely the addition of <code>OP_NOP</code> operation codes to version 0.3.6 of Bitcoin by Satoshi Nakamoto in July 2010. Increasing block sizes was also considered a planned upgrade hard fork, notably by Satoshi himself<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>, until the contentious hard fork of Bitcoin Cash in 2017.</p>
<div class="no-row-height column-margin column-container"><div id="fn18"><p><sup>18</sup>&nbsp;In October 2010, following Jeff Garzik’s proposal to increase the limit directly to 7.168 MB to “match PayPal’s average transaction rate,” Satoshi—well aware this was a “network-incompatible” fix—wrote: “[The upgrade] can be introduced slowly, for instance: if (blocknumber &gt; 115000) maxblocksize = largerlimit. It can start being introduced into versions long before then, so by the time it reaches the block number and takes effect, old versions that don’t have it are already obsolete. When we get close to the limit block number, I can send out an alert to old versions so they know they need to upgrade.” — Satoshi Nakamoto, <em>Re: [PATCH] increase block size limit</em>, 10/04/2010 19:48:40 UTC: <a href="https://bitcointalk.org/index.php?topic=1347.msg15366#msg15366" class="uri">https://bitcointalk.org/index.php?topic=1347.msg15366#msg15366</a>.</p></div></div><p>Outside of BTC, upgrades via hard fork are numerous, often due to a smaller and/or more centralized economy. Examples include Bitcoin Cash, Monero, Ethereum Classic, and Ethereum, where such upgrades occur regularly.</p>
<p>A contentious hard fork aims deliberately to create a new chain, stemming from a community disagreement so strong it leads to secession. It’s usually bilateral.</p>
<p>The first major example of a contentious hard fork was on Ethereum in July 2016, following TheDAO hack. This hard fork sought to recover the hacker’s funds through an “irregular state change.” It was made bilateral by a rule requiring the first 10 blocks post-activation to include the string dao-hard-fork. Since the economic majority supported the reversal, the altered chain retained the Ethereum name and ETH ticker, while the other chain became Ethereum Classic with the ETC ticker.</p>
<p>The second example is the hard fork that led to Bitcoin Cash’s creation in August 2017, following the scalability debate and the block size war. This hard fork did not include SegWit, increased the block size limit to 8 MB, and improved the signature algorithm. It was made bilateral by a rule requiring the activation block to be strictly larger than 1 MB. It also effectively provided replay protection. Since this change happened without the economic majority’s agreement, the chain that didn’t modify the rules kept the Bitcoin name and BTC ticker, while the new chain adopted the name Bitcoin Cash and the BCH ticker.</p>
<div id="fig:hard-forks-eth-bch" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/hard-forks-eth-etc-bch-btc.png" class="img-fluid figure-img"></p>
<figcaption>Examples of bilateral hard forks: ETH/ETC and BCH/BTC.</figcaption>
</figure>
</div>
<p>Note that such a hard fork may involve modifying the difficulty adjustment algorithm. If the computing power is too low to support it, the adjustment might not occur in time. For this reason, Bitcoin Cash implemented an Emergency Difficulty Adjustment (EDA) to adjust more quickly. Ethereum Classic didn’t need this, as Ethereum’s adjustment already occurred at every block.</p>
</section>
<section id="soft-forks" class="level2 unnumbered page-columns page-full">
<h2 class="unnumbered anchored" data-anchor-id="soft-forks">Soft Forks</h2>
<p>Let’s now discuss soft forks, a method of upgrade often misunderstood. A soft fork is a restriction of the consensus rules. By essence, it reduces the set of valid blocks and transactions by adding a rule or modifying an existing one to be more restrictive. A typical example is reducing the block size limit. The explicit addition of the 1 MB limit in October 2010 was, therefore, a soft fork.</p>
<p>A soft fork can be applied while maintaining a single chain. If enforced by the majority of the network’s computing power, there’s no risk of a split. Blocks created by miners following the new rules are entirely compatible with the old rules, so if the new rule chain is longer, it will be considered the correct branch by all nodes. If the soft fork is enforced by a minority, it results in two persistent chains. Both scenarios are illustrated in Figure <a href="#fig:soft-fork" data-reference-type="ref" data-reference="fig:soft-fork">10.4</a>.</p>
<div id="fig:soft-fork" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/soft-fork-induced-forks.png" class="img-fluid figure-img"></p>
<figcaption>Diagram of a soft fork: If the chain following the new rule is longer than the one following the old rule, only the first survives; otherwise, both chains persist.</figcaption>
</figure>
</div>
<p>The concept of a soft fork emerged after that of a hard fork. It was formally discovered by Gavin Andresen in October 2011, who, following his study of Nicolas van Saberhagen’s proposal to add the <code>OP_EVAL</code> operation code<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>, realized that the upgrade could be done using the <code>OP_NOP1</code> operation code without necessarily causing a split<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn19"><p><sup>19</sup>&nbsp;Nicolas van Saberhagen (ByteCoin), <em>OP_EVAL proposal</em>, 10/02/2011 00:49:19 UTC: <a href="https://bitcointalk.org/index.php?topic=46538.msg553689#msg553689" class="uri">https://bitcointalk.org/index.php?topic=46538.msg553689#msg553689</a>.</p></div><div id="fn20"><p><sup>20</sup>&nbsp;“I’m probably reading the code wrong, but I think OP_EVAL wouldn’t cause a blockchain fork!” Gavin Andresen expressed on IRC. — #bitcoin-dev IRC logs, October 2, 2010, archived: <a href="https://web.archive.org/web/20131201200245/http://bitcoinstats.com/irc/bitcoin-dev/logs/2011/10/02" class="uri">https://web.archive.org/web/20131201200245/http://bitcoinstats.com/irc/bitcoin-dev/logs/2011/10/02</a>.</p></div><div id="fn21"><p><sup>21</sup>&nbsp;Satoshi Nakamoto, <em>reverted makefile.unix wx-config – version 0.3.6 (git commit)</em>, 07/29/2010 18:27:12 UTC: <a href="https://sourceforge.net/p/bitcoin/code/119/" class="uri">https://sourceforge.net/p/bitcoin/code/119/</a>.</p></div></div><p>The <code>OP_NOP</code> operation codes are Bitcoin script instructions added by Satoshi in July 2010 with the mere comment “expansion<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>.” The change became effective with version 0.3.6 of the software, which also fixed the 1 RETURN bug and was released on July 29. Their initial role is silent: if they appear in a script, they do nothing but do not invalidate the transaction. The direct consequence is that the behavior of these operation codes can be modified without rendering scripts incompatible with old consensus rules. The addition of this feature indicates that Satoshi had grasped the soft fork mechanism.</p>
<p>A soft fork has a “backward-compatible” nature—or more accurately, it’s upward compatible, as compatibility is ascending, not descending—in that old software versions can continue interacting with the system. Non-mining nodes following old rules continue to see blocks produced as valid. This characteristic is a major advantage over hard forks.</p>
<p>However, this upward compatibility doesn’t mean a soft fork is “soft.” It has a pernicious side in that it makes the modification hard to grasp. Soft forks have several drawbacks.</p>
<p>First, they are not optional. If enforced by the majority of computing power, a soft fork effectively resembles a censorship attack on users following old rules. Thus, a soft fork has a coercive aspect that a hard fork lacks.</p>
<p>Second, a soft fork is challenging to reverse. Newly added functionalities cannot be simply deactivated; once adopted, there’s no easy rollback. Bitcoin SV developers, for instance, deactivated P2SH in February 2020, exposing less attentive users to theft.</p>
<p>Third, a soft fork is not limited in scope. It can increase the effective block size limit (via an auxiliary block, also called an extension block or generalized soft fork). This extension block can also include additional functionalities (like MimbleWimble in Litecoin). It can even alter the protocol’s monetary policy by redefining the base unit<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;How a soft fork can introduce inflation into Bitcoin was explained by developer Peter Todd in 2016. — Peter Todd, <em>Forced Soft Forks</em>, January 18, 2016: <a href="https://petertodd.org/2016/forced-soft-forks" class="uri">https://petertodd.org/2016/forced-soft-forks</a>.</p></div></div><p>Finally, a deep soft fork adds complexity due to the constraints of its application. It introduces new exceptions to consensus rules, generating technical debt for developers.</p>
<p>The archetype of a deep and complex soft fork was the SegWit upgrade, or <em>Segregated Witness</em>, which involved moving transaction signature data (called <em>witness</em> data) to a separate data structure to eliminate transaction malleability. This upgrade, which occurred on August 24, 2017, was initially supposed to be a hard fork until developer Luke-Jr described in 2015 how to make it a soft fork. Backward compatibility was ensured by linking the witness to the block via a Merkle tree root placed in the coinbase transaction and by using anyone-can-spend transaction outputs. Besides fixing the malleability issue, it introduced a versioning system (allowing the later integration of Schnorr-Taproot) and moderately increased the network’s transaction capacity, enabling effective block sizes to exceed 1 MB, up to 4 MB theoretically. It also added four new address types to the protocol.</p>
<p>Moreover, a soft fork requires the majority of the network’s computing power to preserve its significance. If not followed by 51% of computing power in the medium term, its application results in a split. This explains why miner activation is generally preferred over user activation, even though the decision-making power ultimately lies with the users, as we’ll see in Chapter <a href="la-determination-du-protocole.html" data-reference-type="ref" data-reference="ch:determination">11</a>.</p>
<p>On one hand, a User Activated Soft Fork (UASF) involves implementing the soft fork in the software code to take effect at a specific block height or timestamp. This method relies on the belief that the economy applying the upgrade will be significantly majoritarian and that mining activity will follow in the medium term due to higher block rewards.</p>
<p>On the other hand, a Miner Activated Soft Fork (MASF) makes activation dependent on miners signaling support within validated blocks. It activates when a certain signaling threshold (e.g., 95%) is exceeded. This method, whose procedure was described in BIP-9, ensures as much as possible that miners apply the upgrade and that only one chain remains.</p>
<p>The same distinction exists in hard fork activation, but it holds little relevance since computing power cannot prevent a split. Therefore, Miner Activated Hard Forks (MAHF), long supported by proponents of increasing the block size limit, have no particular advantage.</p>
<p>Like hard forks, soft forks can be categorized into two somewhat distinct types: planned upgrade soft forks and contentious soft forks. A soft fork is ideal for upgrading the protocol, allowing nodes to update gradually. Although it requires some synchronization, it’s not as demanding as hard forks.</p>
<p>In BTC, soft forks have been favored by developers since their discovery. Many upgrades have been soft forks, such as Pay to Script Hash (BIP-16), the requirement to specify the block height in the coinbase transaction (BIP-34), and the addition of a signature encoding standard (BIP-66). The additions of <code>OP_CHECKLOCKTIMEVERIFY</code> and <code>OP_CHECKSEQUENCEVERIFY</code> operation codes, allowing time locks in the script language using <code>OP_NOP2</code> and <code>OP_NOP3</code>, were also soft forks. More recently, the adoption of Schnorr-Taproot (or simply Taproot) was a soft fork upgrade.</p>
<p>Litecoin also uses this type of transition. The protocol notably integrated SegWit in May 2017 and Schnorr-Taproot and MimbleWimble (MWEB) in May 2022.</p>
<p>A contentious soft fork aims to force a minority of the community to follow the majority. If successful, there’s only one chain; dissenters have the choice to accept the rules or undertake a minority hard fork. If it fails, two competing chains result.</p>
<p>SegWit is the typical example of a successful contentious soft fork. It wasn’t approved by all major actors (both large block proponents and protocol purists like Mircea Popescu<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> opposed it), but it garnered majority support, allowing it to persist and forcing dissatisfied “big blockers” to migrate to Bitcoin Cash.</p>
<div class="no-row-height column-margin column-container"><div id="fn23"><p><sup>23</sup>&nbsp;Mircea Popescu, <em>There’s a one Bitcoin reward for the death of Pieter Wuille. Details below.</em>, December 10, 2015: <a href="http://trilema.com/2015/theres-a-one-bitcoin-reward-for-the-death-of-pieter-wuille-details-below/" class="uri">http://trilema.com/2015/theres-a-one-bitcoin-reward-for-the-death-of-pieter-wuille-details-below/</a>.</p></div><div id="fn24"><p><sup>24</sup>&nbsp;Amaury Séchet, <em>Bitcoin ABC’s plan for the November 2020 upgrade</em>, August 6, 2020: <a href="https://amaurysechet.medium.com/bitcoin-abcs-plan-for-the-november-2020-upgrade-65fb84c4348f" class="uri">https://amaurysechet.medium.com/bitcoin-abcs-plan-for-the-november-2020-upgrade-65fb84c4348f</a>.</p></div></div><p>An example of a failed contentious soft fork is Bitcoin ABC’s team’s attempt to redirect 8% of Bitcoin Cash’s mining subsidy for their own benefit on November 15, 2020<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>. This attempt, a soft fork due to its restrictive nature, led to a split between a majority branch without redirection (BCH) and a minority branch with it, later renamed “eCash” (XEC).</p>
<p>Thus, whether unanimously approved or only by a majority, soft forks are superior to hard forks. Despite being sometimes more complex, they don’t require synchronization of the entire economy, allowing gradual adaptation—a significant benefit for an open system used by a diverse group like Bitcoin. Supermajority miner signaling minimizes the risk of splits and preserves network effects as much as possible.</p>
<p>However, this major advantage comes at a cost: the clarity of consent. In a hard fork, consent is clear—those who want the change are on the chain they’ve chosen. In a soft fork, consent is more ambiguous—the act of operating on the chain doesn’t necessarily indicate active acceptance of the change but perhaps passive resignation and a refusal to undertake a minority hard fork. As Vitalik Buterin aptly wrote in March 2017:</p>
<p>“Soft forks clearly favor coercion over secession systemically, whereas hard forks have the opposite tendency<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>.”</p>
<div class="no-row-height column-margin column-container"><div id="fn25"><p><sup>25</sup>&nbsp;Vitalik Buterin, <em>Hard Forks, Soft Forks, Defaults and Coercion</em>, March 14, 2017: <a href="https://vitalik.ca/general/2017/03/14/forks_and_markets.html" class="uri">https://vitalik.ca/general/2017/03/14/forks_and_markets.html</a>.</p></div></div><p>Therefore, even though they are generally superior, soft forks aren’t suitable for all situations.</p>
</section>
<section id="bitcoins-plural-evolution" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="bitcoins-plural-evolution">Bitcoin’s Plural Evolution</h2>
<p>Bitcoin’s open and free nature means its protocol can be modified at will. Bitcoin evolves organically, slowly but surely; it’s not a static system with rules dictated by a central authority. Through this, it improves over time.</p>
<p>This openness also implies that Bitcoin’s implementation is necessarily plural. Bitcoin is not a single system but an open model applied more or less faithfully by several protocols. All implementations of Bitcoin form a tree whose branches come from the same trunk and roots.</p>
<p>However, not all branches are equal; not all implementations are equally important. One of them (BTC) is now supermajoritarian, so we naturally call it Bitcoin, and modifying it is (fortunately) difficult. In the next chapter, we’ll examine the underlying mechanism that makes Bitcoin what it is today and how protocol evolution is governed.</p>
<div id="fig:bitcoin-forks-tree" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/bitcoin-forks-tree.png" class="img-fluid figure-img"></p>
<figcaption>Conceptual variations, software modifications, and consensus forks of Bitcoin.</figcaption>
</figure>
</div>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/la-resistance-a-la-censure.html" class="pagination-link" aria-label="Resistance to Censorship">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Resistance to Censorship</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/la-determination-du-protocole.html" class="pagination-link" aria-label="Determining the Protocol">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Determining the Protocol</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © 2024 Konsensus Network
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../index.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../presale.html">
<p>Acheter</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/konsensusn">
      <i class="bi bi-twitter" role="img" aria-label="Twitter">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/konsensusnetwork">
      <i class="bi bi-github" role="img" aria-label="Github">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/konsensusnetwork">
      <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/konsensusnetwork">
      <i class="bi bi-youtube" role="img" aria-label="YouTube">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>